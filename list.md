# Python Control Alignment List

Generated by diffing:
- Dart control dispatch cases in `butterflyui/src/lib/src/core/control_renderer.dart`
- Python schemas in `butterflyui/sdk/python/packages/butterflyui/src/butterflyui/core/schema.py`
- Python control classes in `butterflyui/sdk/python/packages/butterflyui/src/butterflyui/controls/*.py`


> Note: **Candy, Gallery, Skins, Studio, CodeEditor, and Terminal** are treated as *umbrella controls*.
> Their indented entries are **submodules** that live inside the same control (one control ID, many focused parts),
> which gives tools like GitHub Copilot much richer context when you’re navigating or generating code.

---

## Belonging to the Skins control as a whole:
## Skins (umbrella control)

`skins` is the visual identity system of ButterflyUI.

It defines how the entire application looks and behaves stylistically:
colors, materials, effects, typography, motion, interaction feedback, and responsive behavior.

Skins is not a simple theme toggle.
It is a structured, token-driven styling engine designed to:

- Centralize visual configuration
- Support multiple skin profiles
- Allow runtime switching
- Keep styling deterministic and serializable
- Separate design from logic
- Integrate deeply with Candy + Studio

If Candy provides styling primitives,
Skins defines the rules and values that drive them.

### Core Skin Management

- `skins`
  Root orchestrator of the skin system.
  Responsibilities:
  - manage available skins
  - load/save skin configurations
  - broadcast skin updates
  - provide resolved tokens to runtime
  - ensure consistent application-wide styling

- `selector`
  UI for choosing the active skin.
  Supports:
  - list/grid of skins
  - preview thumbnails
  - metadata display (author, version, description)
  - quick switch

- `preset`
  Built-in skin template.
  Used to:
  - provide starting points (Dark, Light, Glass, Neon, Minimal)
  - enforce structured defaults
  - speed up creation workflow

- `create_skin`
  Entry workflow for creating a new skin.
  Can:
  - clone from preset
  - clone from existing skin
  - create from blank template

- `edit_skin`
  Load an existing skin into the editing system.

- `delete_skin`
  Remove a skin configuration (with safety confirmation).

- `apply`
  Apply the selected skin to the runtime.
  Should:
  - propagate resolved tokens
  - refresh UI
  - trigger transition animations (if enabled)

- `clear`
  Reset editing state or revert to default values.

### Token System & Mapping

- `token_mapper`
  Core transformation engine that converts raw skin configuration
  into resolved runtime tokens.

  Responsibilities:
  - resolve token inheritance
  - compute derived values (e.g., hover color from base color)
  - apply responsive variants
  - provide fallback values
  - validate token types

Tokens may include:
- color tokens
- spacing tokens
- typography tokens
- radius tokens
- motion tokens
- elevation tokens

Skins should avoid raw values in UI controls —
everything should resolve through tokens.

### Visual Foundations

These define the raw visual building blocks used by Candy.

- `colors`
  Defines:
  - primary/secondary/accent
  - background/surface variants
  - success/warning/error
  - text hierarchies
  - semantic states (hover, pressed, disabled)

- `fonts`
  Controls:
  - font families
  - weight scale
  - heading/body scale
  - line height
  - letter spacing

- `icons`
  Icon pack configuration.
  Defines:
  - icon family
  - stroke thickness
  - fill mode
  - scaling rules

- `background`
  Global surface backgrounds.
  May support:
  - gradients
  - textures
  - layered backgrounds
  - image-based backgrounds

- `border`
  Border styling tokens:
  - thickness
  - radius
  - style (solid/dashed/etc.)
  - color mapping

- `shadow`
  Elevation model.
  Defines:
  - shadow levels
  - softness
  - spread
  - blur
  - color tint

- `outline`
  Stroke styling.
  Often used for:
  - focus rings
  - accessibility indicators
  - high contrast modes

### Advanced Visual Systems

These push Skins beyond basic theming.

- `materials`
  Defines surface material behavior.
  Examples:
  - glassmorphism
  - acrylic blur
  - matte
  - neon glow
  - metallic finishes
  Materials can combine:
  - blur
  - transparency
  - noise
  - reflection overlays

- `effects`
  Visual modifiers that can apply globally or per component.
  Examples:
  - glow
  - blur
  - grain
  - noise
  - bloom
  - chromatic aberration

- `particles`
  Particle systems for visual flair.
  Examples:
  - background sparkle
  - hover bursts
  - animated gradients
  Should remain optional and performance-aware.

- `shaders`
  GPU-level styling.
  Used for:
  - animated backgrounds
  - distortion
  - custom rendering effects
  Must be isolated and safe to disable on low-power systems.

### Motion & Interaction

- `animation`
  Defines animation behavior globally.
  Controls:
  - duration scale
  - easing curves
  - spring configs
  - motion density
  Ensures consistent motion language.

- `transition`
  Governs state transitions:
  - hover transitions
  - page transitions
  - modal open/close
  - skin switching animation

- `interaction`
  Interaction feedback styling:
  - hover effects
  - pressed effects
  - ripple effects
  - focus visuals
  - drag indicators

This ensures consistent UX across all controls.

### Layout & Responsiveness

- `layout`
  Defines:
  - default spacing scale
  - grid systems
  - alignment defaults
  - container behavior
  - default padding/margins

- `responsive`
  Controls:
  - breakpoints
  - adaptive scaling
  - font scaling
  - layout overrides per size
  - mobile vs desktop behavior

### Editing Systems

Each visual subsystem has a dedicated editor to prevent chaos.

- `editor`
  Main editing surface wrapper.

- `effect_editor`
  Configure visual effects.

- `particle_editor`
  Configure particle behavior.

- `shader_editor`
  Configure shader parameters.

- `material_editor`
  Configure surface material layers.

- `icon_editor`
  Configure icon family + styling.

- `font_editor`
  Configure typography system.

- `color_editor`
  Configure palette + semantic colors.

- `background_editor`
  Configure background layers.

- `border_editor`
  Configure border tokens.

- `shadow_editor`
  Configure elevation/shadow levels.

- `outline_editor`
  Configure outline/focus tokens.

Each editor should:
- validate input
- preview live
- update tokens
- remain modular

### Architectural Philosophy

Skins is:

- Token-driven
- Runtime-switchable
- Structured and modular
- Performance-aware
- Deeply integrated with Candy and Studio

Skins defines identity.

If Studio constructs,
and CodeEditor engineers,
Skins gives everything its visual soul.

---

## Belonging to the Gallery control as a whole:
Perfect. Gallery is more important than it looks.

This is not just a grid of images — this is your **asset intelligence layer** for ButterflyUI.
It connects media, skins, fonts, and external resources into one structured browsing and selection system.

Here is the full, detailed architectural block:

## Gallery (umbrella control)

`gallery` is the structured asset browser system of ButterflyUI.

It provides a unified interface for browsing, previewing, filtering, selecting, and applying
assets such as:

- Fonts
- Images
- Video
- Audio
- Documents
- Skins
- Presets

Gallery is not a static grid.
It is a dynamic, type-aware asset orchestration layer designed to:

- Support multiple media types
- Provide consistent preview/render behavior
- Allow filtering, sorting, and search
- Handle large datasets efficiently
- Support selection modes (single, multi, toggle)
- Integrate directly with Studio and Skins

If Skins defines identity,
Gallery supplies the resources.

### Core Gallery Architecture

- `gallery`
  Root orchestrator for the asset system.
  Responsibilities:
  - manage asset datasets
  - register asset types
  - coordinate filters and search
  - manage selection state
  - trigger apply/clear actions
  - provide type-specific renderers

Gallery should be:
- media-type aware
- extensible
- virtualized for performance
- capable of remote + local sources

### Layout & Navigation

- `grid_layout`
  Main layout engine for asset display.
  Handles:
  - responsive column count
  - spacing and alignment
  - lazy loading / virtualization
  - adaptive tile sizing

- `pagination`
  Used for large datasets.
  Supports:
  - page switching
  - page size control
  - infinite scroll mode (optional)

- `section_header`
  Group separator inside gallery.
  Used for:
  - category grouping
  - recent vs all
  - recommended sections

- `toolbar`
  Top-level action container.
  May include:
  - search
  - filter
  - sort
  - view toggle
  - bulk actions

### Search, Filter & Sorting

- `search_bar`
  Entry point for query-based filtering.
  Supports:
  - text search
  - type-aware search
  - live filtering

- `filter_bar`
  Structured filtering interface.
  Examples:
  - file type
  - tags
  - date
  - author
  - resolution
  - duration (for audio/video)

- `sort_bar`
  Sorting controls.
  Examples:
  - name (A-Z)
  - date added
  - size
  - popularity
  - custom metadata

Gallery filtering should not mutate data —
it should compute a derived filtered view.

### Item System (Tile Architecture)

Each asset is represented as a tile composed of smaller submodules.

- `item_tile` ✅
  Main asset container.
  Combines:
  - preview
  - metadata
  - selection controls
  - action buttons

- `item_preview`
  Visual representation of the asset.
  Behavior varies by type:
  - image thumbnail
  - video snapshot
  - audio waveform
  - font preview sample text
  - document icon or first page preview

- `item_meta_row`
  Metadata display.
  Can show:
  - name
  - size
  - type
  - duration
  - resolution
  - author

- `item_badge`
  Small indicator tag.
  Used for:
  - "new"
  - "premium"
  - "selected"
  - "favorite"
  - file type labels

- `item_actions`
  Inline action buttons.
  Examples:
  - preview
  - download
  - edit
  - delete
  - apply

- `item_selectable`
  Wrapper enabling selection state logic.

- `item_drag_handle`
  Enables drag-based movement of asset.

- `item_drop_target`
  Accepts dropped items for:
  - categorization
  - reordering
  - grouping

- `item_reorder_handle`
  Specific UI for manual reordering inside collections.

### Selection System

Gallery must support multiple selection strategies.

- `item_selection_checkbox`
  Multi-select via checkbox.

- `item_selection_radio`
  Single-select mode.

- `item_selection_switch`
  Toggle selection mode.

- `select_all`
  Bulk select visible items.

- `deselect_all`
  Bulk clear selection.

- `apply`
  Commit selection to calling context.
  For example:
  - apply font to Skins
  - insert image into Studio
  - assign video to background

- `clear`
  Reset current selection state.

### Media-Type Modules

Each asset type has specialized behavior.

#### Fonts

- `fonts`
  Font dataset management.

- `font_picker`
  Selection UI specialized for fonts.

- `font_renderer`
  Live preview renderer.
  Should:
  - render sample text
  - show weights/styles
  - display character sets

- `apply_font`
  Applies selected font to:
  - Skins typography
  - Studio element
  - Global theme

#### Images

- `image`
  Image asset handler.

- `image_picker`
  Image selection UI.

- `image_renderer`
  Optimized image preview.
  Should:
  - lazy load
  - handle different resolutions
  - support fallback

- `apply_image`
  Applies selected image to:
  - background
  - component
  - asset slot

- `set_as_wallpaper`
  Specialized application for:
  - global background
  - skin background layer

#### Video

- `video`
  Video asset manager.

- `video_picker`
  Video selection UI.

- `video_renderer`
  Lightweight preview:
  - thumbnail extraction
  - short looping preview (optional)
  - duration indicator

#### Audio

- `audio`
  Audio asset manager.

- `audio_picker`
  Audio selection UI.

- `audio_renderer`
  Audio preview:
  - waveform visualization
  - duration display
  - playback controls

#### Documents

- `document`
  Generic document asset handler.

- `document_picker`
  Document selection UI.

- `document_renderer`
  Preview strategy:
  - icon-based
  - first-page snapshot
  - metadata preview

### States & Feedback

- `empty_state`
  Displayed when no items are available.
  Should:
  - explain why empty
  - offer action (upload/import)

- `loading_skeleton`
  Placeholder UI while loading.
  Ensures:
  - visual continuity
  - no layout shift
  - perceived performance

### Presets & Skin Integration

- `presets`
  Predefined asset collections.
  Examples:
  - curated icon sets
  - recommended backgrounds
  - starter font bundles

- `skins`
  Direct integration with the Skins system.
  Allows:
  - browsing skins inside gallery
  - previewing skin before apply
  - applying full visual identity

### Architectural Philosophy

Gallery is:

- Type-aware
- Extensible
- Performance-conscious
- Selection-driven
- Deeply integrated with Skins and Studio
- Structured for both local and remote assets

If Studio constructs,
and Skins defines identity,
Gallery supplies the resources that bring everything to life.

---

## Belonging to the Candy control as a whole:
## Candy (umbrella control)

`candy` is the foundational styling and layout system of ButterflyUI.

It provides the primitive building blocks used by every other control:
layout containers, surfaces, typography, decoration, motion, and visual modifiers.

Candy is intentionally low-level and composable.

It is not a theme system (that is Skins).
It is not a visual builder (that is Studio).
It is not an IDE (that is CodeEditor).

Candy is the structural and visual primitive layer that all of those systems rely on.

Design goals:
- Composable layout primitives
- Deterministic rendering
- Token-driven styling (via Skins)
- Separation of structure and decoration
- Motion and interaction as first-class citizens
- Performance-aware rendering

### Core Philosophy

Candy follows a layered rendering model:

Structure → Surface → Decoration → Effects → Motion → Interaction

Each control should:
- Do one thing well
- Be stackable
- Accept tokens instead of raw style values
- Remain predictable

Candy is your “traditional craftsmanship” layer.
Clean primitives. No chaos. No magic.

## Layout Primitives

These are structural containers used everywhere.

- `row`
  Horizontal layout container.
  Responsibilities:
  - align children left-to-right
  - control spacing and alignment
  - support main/cross axis constraints
  Foundation for toolbars and inline layouts.

- `column`
  Vertical layout container.
  Used for:
  - stacked content
  - panels
  - forms
  - vertical grouping

- `stack`
  Overlay layout container.
  Children are layered on top of each other.
  Used for:
  - overlays
  - badges
  - floating elements
  - complex compositions

- `wrap`
  Flow layout.
  Automatically wraps children when space runs out.
  Ideal for:
  - tag clouds
  - responsive grids
  - chip groups

- `container`
  Single-child box with layout + style support.
  Supports:
  - padding
  - constraints
  - alignment
  - decoration
  Often the most commonly used wrapper.

- `surface`
  A styled visual surface.
  Acts as a semantic layer for:
  - cards
  - panels
  - sheets
  - backgrounds
  Should respect Skins tokens.

- `align`
  Aligns child within available space.

- `center`
  Shortcut alignment to center.

- `spacer`
  Flexible or fixed spacing element.
  Keeps layout clean and predictable.

- `aspect_ratio`
  Enforces fixed ratio for its child.
  Useful for:
  - media previews
  - thumbnails
  - responsive elements

- `overflow_box`
  Allows child to exceed parent constraints.
  Useful for:
  - pop effects
  - animated expansions

- `fitted_box`
  Scales child to fit inside constraints.

## Interactive Primitives

- `button`
  Clickable action primitive.
  Must support:
  - hover state
  - pressed state
  - disabled state
  - focus state
  - motion/transition integration
  Should derive styling from Skins tokens.

- `badge`
  Small status indicator.
  Used for:
  - counts
  - alerts
  - status flags

- `avatar`
  Profile/image representation.
  Supports:
  - circle/square shapes
  - fallback initials
  - border overlays

- `icon`
  Icon rendering primitive.
  Should support:
  - token-based size
  - color inheritance
  - animation compatibility

- `text`
  Typography primitive.
  Must:
  - use token-driven font scale
  - support semantic roles (heading, body, caption)
  - handle overflow strategies

## Decoration & Styling Modifiers

These wrap or modify visual output.

- `border`
  Stroke around element.
  Controlled via:
  - thickness
  - radius
  - color tokens

- `shadow`
  Elevation effect.
  Should use Skins elevation levels.

- `outline`
  Focus or accent stroke.
  Used for:
  - accessibility
  - selected states

- `gradient`
  Gradient background modifier.
  Can support:
  - linear
  - radial
  - animated gradients

- `decorated_box`
  Composite decoration container.
  Combines:
  - border
  - gradient
  - shadow
  - background layers

- `clip`
  Clips child to shape.
  Used for:
  - rounded corners
  - custom shapes

## Effects & Advanced Visual Layers

These enhance presentation without altering structure.

- `effects`
  Visual modifiers such as:
  - blur
  - glow
  - noise
  - bloom
  - color filters

- `particles`
  Particle rendering layer.
  Should:
  - remain optional
  - be performance aware
  - integrate with Skins tokens

- `canvas`
  Custom drawing surface.
  Used for:
  - procedural graphics
  - custom visual components
  - advanced rendering needs

## Motion & Animation

Candy treats motion as structural, not decorative.

- `animation`
  Defines animation drivers.
  Supports:
  - duration
  - easing
  - spring curves
  - chained sequences

- `transition`
  State-based animated transitions.
  Used for:
  - hover state changes
  - page transitions
  - theme switching

- `motion`
  Primitive motion system.
  Provides:
  - gesture-driven animation
  - physics-based animation
  - transform animations (scale, rotate, translate)
  Motion should be token-aware for consistency.

---

## Architectural Role in ButterflyUI

Candy is:

- The lowest visual layer
- Token-driven but token-agnostic
- Composable and predictable
- Performance-focused
- Used by every other umbrella control

---

Hierarchy of responsibility:

Candy → defines structure and primitives  
Skins → defines visual identity via tokens  
Studio → builds UI using Candy  
CodeEditor → builds logic using Candy  
Gallery → renders assets using Candy  
Terminal → renders execution surfaces using Candy  

Candy is the craft.

Everything else is built on top of it.

---

## The shared pattern for all umbrella controls:
Yep — and your LIST.md already sets the precedent: **Candy, Gallery, Skins, Studio, CodeEditor, Terminal are umbrella controls** with submodules living under one control ID. 

Below is the “extra layer” you’re asking for: how to make **Candy / CodeEditor / Terminal / Skins / Gallery** behave like **Studio** does — i.e. a **host control** where users pick submodules to assemble their own program (their own IDE, their own asset browser, their own theme editor, etc.).

---

Give every umbrella control the same 3-part architecture:

### 1) A Host (the control itself)

* Owns the **layout/workbench**
* Owns **core services**
* Owns **registries** (module registration)
* Owns **persistence** (layout + settings + module enablement)

### 2) Modules (submodules)

Each module declares:

* `id`, `version`, `depends_on`
* what it contributes: **panels**, **tools**, **views**, **providers**, **commands**
* what services it needs from the host

### 3) A Manifest (user configuration)

A serializable config that selects:

* enabled modules
* default layout
* keybinds
* providers (local/remote, etc.)

If you do this consistently, users can “compose software” the old-school way: **shell + plugins**, like classic IDEs.

---

# Candy as an umbrella control (User assembles a design language)

Candy in your doc is the primitives layer. 
To make it “user-buildable”, you don’t want users picking *every primitive*. Instead, let them pick **systems**:

## Candy module roles

### A) Foundations

* `layout_primitives` (row/column/stack/wrap/container/spacer/etc.)
* `typography` (text roles, scaling rules)
* `icons` (glyph/icon packs, sizing rules)
* `surfaces` (surface/card/panel conventions)

### B) Interaction language

* `states` (hover/pressed/focus/disabled)
* `hit_slop` and accessibility defaults
* `gesture_profiles` (desktop vs touch feel)

### C) Motion language

* `motion_engine` (springs/curves)
* `transition_pack` (page/modal/hover transitions)
* `stagger_pack` (list reveal)

### D) Effects systems (optional packs)

* `glass_pack` (blur, acrylic, noise)
* `glow_pack`
* `grain_pack`
* `particles_pack`
* `shader_pack`

### E) Composition helpers

* `style_resolver` (token lookup + variants)
* `variant_system` (intent/size/shape)
* `component_recipes` (button recipe, card recipe, input recipe)

## Candy manifest example (conceptually)

* enabledPacks: `["foundations", "interaction", "motion", "glass_pack"]`
* defaultVariant: `{ density: "comfortable", radius: "md" }`
* performanceMode: `balanced | low_power | max`

## Pubspec packages Candy often benefits from

* `vector_math` (transforms/math helpers)
* `flutter_svg` (icons/illustrations)
* `material_color_utilities` (nice token generation / tonal palettes if you want it)
* `animations` (optional helper widgets, if you want classic transitions fast)
* Effects-heavy packs might need shader plumbing (often custom), but you can keep it optional.

---

# CodeEditor as an umbrella control (Users build their own IDE)

Your LIST already describes CodeEditor as a modular workbench. 
To make it *user-assembled*, treat “IDE features” as modules you can switch on/off.

## CodeEditor module roles

### A) Workbench + Docking

* `workbench_editor` (layout coordinator)
* `dock`, `dock_pane`, `dock_graph`
* `layout_persistence` (save/restore)

### B) Document system

* `workspace_explorer`, `file_tree`
* `document_model` (buffers/docs)
* `tab_system` (tabs/splits)

### C) Language intelligence (plug-in providers)

* `diagnostics_provider` (lint/type errors)
* `formatter_provider`
* `symbols_provider` (outline tree)
* `completion_provider`
* `goto_provider` (definition/references)

This is where you can support multiple backends:

* local analyzers
* LSP
* “AI suggestions” provider
* simple regex-based fallback

### D) Search systems

* `text_search`
* `semantic_search` (optional)
* `command_palette`

### E) Dev workflows

* `diff`
* `git_integration` (optional)
* `tasks` (run/build/test) that can delegate to Terminal

## CodeEditor manifest ideas

* enabledPanels: explorer, search, diagnostics, outline, diff
* enabledProviders: lsp, formatter, semantic_search
* keymap: vscode | sublime | custom
* fileTypes: what languages are registered

## Pubspec packages that help CodeEditor feel “real”

* `flutter_inappwebview` or `webview_flutter` (if Monaco is hosted via WebView; depends on your current approach)
* `file_picker`, `path`, `path_provider`
* `watcher` (file watching)
* `hotkey_manager` (desktop shortcuts)
* `window_manager` (desktop window UX)
* `archive` (workspace export)
* For protocol/LSP: `json_rpc_2` (or your own protocol layer), `web_socket_channel` (if talking to servers)
* For diff prettiness: often custom, but `collection` helps.

---

# Terminal as an umbrella control (Users build their own “workbench terminal”)

Your Terminal section is already very plugin-friendly (sessions, tabs, output mapping, progress, etc.). 
To make it user-assembled, the key is: **multiple backends** + **multiple renderers**.

## Terminal module roles

### A) Backend bridges (swappable engines)

* `process_bridge_local` (spawn local processes)
* `process_bridge_pty` (PTY-style true terminal)
* `process_bridge_remote` (SSH / remote agent)
* `process_bridge_sandbox` (restricted command runner for “safe mode”)

### B) Output shaping + renderers

* `output_mapper_basic`
* `ansi_parser` (optional)
* `stream_view_plain`
* `stream_view_rich` (links, folding, grouping)
* `timeline_view` (structured runs)

### C) Session/workflow modules

* `tabs`
* `presets`
* `execution_lane` (queue + concurrency policies)
* `stdin_tools` (injector, macros)

### D) Extras

* `log_panel`
* `progress_view`
* `replay_recorder` (record a session and replay it)

## Terminal manifest ideas

* backend: `local | pty | remote`
* viewsEnabled: stream_view, timeline, progress, logs
* safetyPolicy: allowlist commands, block destructive commands
* concurrency: max jobs, cancel policy

## Pubspec packages that help Terminal

* `process` (or direct `dart:io` Process; package depends on your style)
* `xterm` (very useful if you want real terminal emulation rendering)
* `hotkey_manager`, `window_manager`
* `collection`, `logging`
* `synchronized` (job lanes / locking)
* `path` / `path_provider` (logs + session history persistence)

---

# Skins as an umbrella control (Users build identity systems)

Skins is already token-driven in your doc. 
To make it user-configurable like Studio, split it into **token pipelines** + **editors** + **preview surfaces**.

## Skins module roles

### A) Token pipeline

* `token_schema` (what tokens exist)
* `token_mapper` (resolve inheritance/derived values)
* `token_validator` (types, ranges)
* `token_exporters` (export to json, export to code, export to CSS-like maps)

### B) Editors (users can enable/disable complexity)

* `color_editor`
* `typography_editor`
* `motion_editor`
* `material_editor` (glass/neon/etc.)
* `effect_editor`
* `icon_editor`

### C) Preview & testing

* `preview_surface` (live sample app)
* `component_preview_gallery` (see how controls react)
* `accessibility_preview` (contrast, focus visibility)

### D) Distribution

* `skins_registry` (installed skins)
* `skins_market` (optional, if you ever want remote browsing)
* `versioning` + migrations (skin format changes)

## Skins manifest ideas

* enabledEditors: colors/fonts/motion/materials
* previewMode: minimal | full_app | component_grid
* constraints: enforce contrast, clamp motion duration, etc.

## Pubspec packages that help Skins

* `shared_preferences` (simple persistence)
* `isar` or `hive` (skin library + metadata)
* `material_color_utilities` (palette generation / tonal rules)
* `collection`, `uuid`
* Optional: `color_models` (if you want advanced color spaces)

---

# Gallery as an umbrella control (Users build their “asset intelligence layer”)

Your Gallery writeup is already perfect for modularization. 
To make it truly “user-built”, focus on **sources** + **type handlers** + **views**.

## Gallery module roles

### A) Asset sources (where assets come from)

* `local_folder_source`
* `project_assets_source`
* `remote_http_source`
* `huggingface_source` (for Matrix-like stuff)
* `marketplace_source`

Each source implements:

* list/query
* fetch/resolve
* caching rules

### B) Type handlers (how each asset behaves)

* `image_handler` (thumb, preview, metadata)
* `video_handler`
* `audio_handler`
* `font_handler`
* `document_handler`
* `skin_handler` (ties directly into Skins)

### C) Views (how assets are shown)

* `grid_layout`
* `list_layout`
* `details_view`
* `compare_view`
* `quick_preview` (spacebar preview like classic file browsers)

### D) Selection & application adapters

* selection modes: single/multi
* `apply_adapters`:

  * “apply selected image to Studio element”
  * “apply selected font to Skins typography”
  * “apply selected skin to runtime”

## Gallery manifest ideas

* enabledSources: local/project/remote
* enabledTypes: image/video/audio/font/skins
* viewsEnabled: grid/list/details/preview
* cachePolicy: aggressive | balanced | minimal

## Pubspec packages that help Gallery

* `file_picker`
* `path`, `path_provider`
* `mime`
* `extended_image` (thumb caching)
* `video_player` (light preview)
* `just_audio` (audio preview)
* `isar` / `hive` (asset index + cache metadata)
* `http` (remote sources)

---

## The “unifying glue” that makes all umbrellas compose nicely

If you want users to mix-and-match Candy/Skins/Gallery/CodeEditor/Terminal/Studio in *one app* without mess, add 3 cross-cutting registries that every umbrella can contribute to:

1. **Command Registry**

* shared command IDs (`studio.export`, `terminal.runPreset`, `editor.format`)
* binds to shortcut service(s)

2. **Panel Registry**

* everything dockable uses the same panel spec type
* so users can dock “Gallery > Assets” next to “CodeEditor > Diagnostics”

3. **Asset Slot / Apply Registry**

* a standard way to say: “I can accept an Image here”
* Gallery can then “apply” into any tool consistently

This makes ButterflyUI feel like an “application platform”, not disconnected mega-controls.

---

## ButterflyUI Control Catalog (detailed):

These controls are not simple layout primitives.
They are higher-level visual and stylistic systems that give ButterflyUI its distinct character.

They are designed to:
- Be token-aware (integrate with Skins)
- Remain composable with Candy primitives
- Support high-performance rendering
- Provide modern, expressive UI capabilities

### Visual Dynamics & Advanced Gradients

- `animated_gradient` ✅
  A dynamic gradient system that supports time-based animation.
  Features may include:
  - color interpolation over time
  - animated angle rotation
  - shifting stop positions
  - looping and ping-pong modes
  - performance throttling
  Designed for backgrounds, hero sections, and dynamic surfaces.
  Should support GPU acceleration where possible.

- `gradient` ✅
  Structured gradient definition layer.
  Supports:
  - linear gradients
  - radial gradients
  - conic/sweep gradients
  - multiple color stops
  - opacity layering
  Should integrate with token colors and responsive overrides.

- `gradient_editor` ✅
  Visual editor for constructing gradients.
  Must support:
  - interactive stop manipulation
  - color picking per stop
  - angle controls
  - live preview
  - export to token format

- `gradient_sweep` ✅
  Specialized conic/sweep gradient control.
  Useful for:
  - progress indicators
  - circular highlights
  - radial UI accents
  Should allow animated sweep transitions.

### Avatar & Identity Controls

- `avatar_stack` ✅
  Compositional layout for multiple avatar elements.
  Designed for:
  - overlapping user indicators
  - team previews
  - stacked profile representations
  Must support:
  - overlap offset control
  - stacking order logic
  - max-visible logic with "+X" overflow badge
  - interactive hover expansion

- `badge` ✅
  Lightweight status indicator system.
  Supports:
  - numeric counts
  - dot indicators
  - severity levels (success/warn/error)
  - animated pulse mode
  Should integrate with elevation and motion tokens.

### Color & Blending Systems

- `color_picker` ✅
  Advanced color selection control.
  Features:
  - RGB / HSL / HEX input
  - alpha transparency control
  - eyedropper support (if platform allows)
  - recent colors memory
  - token-aware preview
  Must emit structured color objects, not raw strings.

- `color_swatch_grid` ✅
  Structured grid of predefined color tokens.
  Used for:
  - quick selection
  - theme preview
  - curated palettes
  Supports:
  - grouping by semantic role
  - selection highlighting
  - responsive layout

- `blend_mode_picker` ✅
  UI for selecting blend modes.
  Supports:
  - multiply
  - overlay
  - screen
  - soft light
  - custom shader blends
  Must preview effect in real time.
  Designed for advanced visual composition workflows.

### Surface Styling & Effects

- `container_style` ✅
  Structured styling system for containers.
  Encapsulates:
  - padding
  - radius
  - surface elevation
  - background layering
  - border tokens
  Allows reusable container style presets.

- `button_style` ✅
  Dedicated styling configuration for buttons.
  Should define:
  - base state
  - hover state
  - pressed state
  - disabled state
  - focus ring
  - motion behavior
  Encourages consistent interaction language across the system.

- `border` ✅
  Full border system.
  Supports:
  - per-side control
  - responsive thickness
  - dynamic color linking
  - animated border transitions

- `border_side` ✅
  Fine-grained border configuration.
  Enables:
  - different colors per side
  - mixed thickness
  - asymmetric styling

- `glass_blur` ✅
  Glassmorphism effect layer.
  Combines:
  - background blur
  - transparency
  - subtle noise overlay
  - border glow
  Must remain performant and degrade gracefully.

- `glow_effect` ✅
  Outer glow system.
  Supports:
  - soft glow
  - directional glow
  - animated intensity
  - neon-style highlights

- `neon_edge` ✅
  High-intensity edge lighting effect.
  Designed for:
  - cyberpunk aesthetics
  - gaming UI
  - high contrast modes
  Can combine with glow + animated gradients.

- `grain_overlay` ✅
  Film-grain / texture overlay.
  Adds:
  - subtle visual noise
  - depth perception
  - anti-banding texture
  Should be GPU-efficient and optional.

### Motion & Celebration Effects

- `confetti_burst` ✅
  Particle-based celebratory animation.
  Supports:
  - emission burst
  - physics simulation
  - color variation
  - duration control
  Designed for:
  - success states
  - reward events
  - milestone feedback

- `chromatic_shift` ✅
  RGB channel offset distortion effect.
  Used for:
  - glitch aesthetics
  - hover distortion
  - transition effects
  Must remain subtle and performance aware.

### Noise & Organic Systems

- `noise_field` ✅
  Procedural noise generator.
  Can generate:
  - Perlin noise
  - simplex noise
  - turbulence patterns
  Used for:
  - animated backgrounds
  - blob fields
  - shader inputs

- `noise_displacement` ✅
  Distortion effect based on noise input.
  Used for:
  - liquid effects
  - glitch transitions
  - heat-wave distortions
  Must allow strength control and animation speed.

- `blob_field` ✅
  Organic shape generator.
  Produces:
  - fluid blobs
  - animated shape morphing
  - layered blob backgrounds
  Often combined with gradients and noise.
  Ideal for modern hero sections and dynamic surfaces.

### Launch & Identity

- `splash` ✅
  Entry-screen presentation control.
  Used for:
  - application startup
  - loading states
  - brand reveal
  - animated logo transitions
  Supports:
  - timed transitions
  - background effects
  - progress indicators
  - optional skip behavior
  Should integrate with animation + gradient systems.

- `emoji_icon` ✅
  Emoji-based icon renderer.
  Used when:
  - lightweight visual symbol is needed
  - expressive UX is preferred over SVG
  Must support:
  - scalable rendering
  - token-based sizing
  - fallback compatibility

- `emoji_picker` ✅
  Emoji selection  interface.
  Supports:
  - category grouping
  - search
  - recent emojis
  - skin tone variants
  Should emit structured emoji metadata.

### Forms & Input Systems

- `auto_form` ✅
  Schema-driven form generator.
  Generates forms automatically based on:
  - field definitions
  - validation rules
  - token-based styling
  Supports:
  - dynamic field visibility
  - validation states
  - submit hooks
  - layout configuration

- `combo_box` ✅
  Hybrid input + dropdown selector.
  Supports:
  - free text input
  - suggestion list
  - keyboard navigation
  - async options loading

- `dropdown` ✅
  Structured dropdown selector.
  Must support:
  - single-select
  - grouped items
  - disabled options
  - animated open/close

- `multi_pick` ✅
  Multi-selection input control.
  Used for:
  - tag selection
  - category filters
  - multi-assign interfaces
  Should integrate with chip system.

- `filepicker` ✅
  File selection control.
  Supports:
  - local file browsing
  - drag-and-drop
  - file type filtering
  - multi-file mode
  Should return structured file metadata.

### Date & Time Controls

- `date_select` ✅
  Single date picker.
  Must support:
  - calendar view
  - month navigation
  - locale formatting
  - disabled date rules

- `date_range` ✅
  Dual date selector for range picking.
  Supports:
  - start/end logic
  - visual range highlighting
  - validation constraints

- `date_span` ✅
  Preset-based time span selector.
  Examples:
  - last 7 days
  - last 30 days
  - this month
  - custom
  Useful for analytics dashboards.

### Navigation & Structural UI

- `breadcrumb_bar` ✅
  Hierarchical navigation indicator.
  Displays:
  - path structure
  - clickable ancestors
  - optional dropdown on levels
  Used for:
  - file navigation
  - settings hierarchy
  - multi-level apps

- `filter_chips_bar` ✅
  Horizontal list of filter chips.
  Supports:
  - toggling
  - multi-select
  - removable chips
  - dynamic chip creation
  Often paired with Gallery or dashboards.

- `drag_region` ✅
  Region that enables window dragging (desktop apps).
  Important for:
  - custom title bars
  - frameless windows
  Must respect platform boundaries.

- `container` ✅
  Flexible structural wrapper.
  Used for:
  - grouping
  - styling
  - layout isolation
  This is a frequently reused high-level wrapper in application-level components.

### Chat & Messaging Systems

- `chat` ✅
  Full conversation container.
  Manages:
  - message list
  - input field
  - scroll behavior
  - message grouping
  - timestamps
  Designed for AI, support, or social interfaces.

- `chat_bubble` ✅
  Individual styled message container.
  Supports:
  - sender alignment
  - message grouping
  - avatar integration
  - status indicators

- `message_bubble` ✅
  More generic message container.
  Used outside chat contexts (notifications, system messages).
  Can support:
  - severity styling
  - icon embedding
  - inline actions

### Content Rendering

- `markdown` ✅
  Markdown rendering component.
  Must support:
  - headings
  - code blocks
  - lists
  - links
  - tables
  - inline styling
  Should sanitize input safely.

- `code_block` ✅
  Styled code display.
  Supports:
  - syntax highlighting
  - copy button
  - line numbers
  - optional diff highlight

- `html` ✅
  Safe HTML rendering component.
  Must:
  - sanitize content
  - prevent script execution
  - allow safe inline styling
  Used for trusted dynamic content.

### Data Visualization

- `bar_chart` ✅
  Structured bar visualization component.
  Supports:
  - categorical datasets
  - stacked bars
  - grouped bars
  - animated transitions
  - tooltips

- `line_chart` ✅
  Time-series or continuous data visualization.
  Supports:
  - multiple data lines
  - smooth curves
  - zoom/pan (optional)
  - interactive tooltips
  - animation on data update
  Designed for dashboards and analytics.

### Gallery Integration

- `item_tile` ✅
  Reusable tile component for content display.
  Can represent:
  - assets
  - products
  - cards
  - preview items
  Should support:
  - hover states
  - selectable mode
  - action overlays

### Overlays & System UI

- `notification_host` ✅
  The central overlay manager for notifications and transient UI messages.
  Responsibilities:
  - owns the overlay layer where toasts/snackbars/banners are rendered
  - manages stacking order, placement, and safe-area offsets
  - handles timing (auto-dismiss), persistence, and queueing
  - resolves collisions (multiple notifications at once)
  - optionally supports interactive notifications (actions, undo, open)
  Think of it as the “OS notification center” for ButterflyUI apps.

- `bottom_sheet`
  A modal sheet that slides in from the bottom (mobile-first pattern, still great on desktop).
  Designed for:
  - quick actions
  - contextual menus
  - compact forms
  - pickers and filters
  Should support:
  - snap points (collapsed/half/full)
  - drag-to-dismiss
  - background scrim and focus trapping
  - keyboard-safe layout on mobile

- `modal` ✅
  Focused blocking dialog surface for confirmation and structured workflows.
  Used for:
  - destructive confirmations
  - short forms/wizards
  - settings or detail popups
  Should support:
  - focus trapping and keyboard navigation
  - backdrop dismiss rules
  - primary/secondary actions
  - safe serialization of open state and payload

- `toast` ✅
  Lightweight transient status message for non-blocking feedback.
  Useful for:
  - save success/error feedback
  - clipboard and quick-action confirmations
  - short-lived background task updates
  Should support:
  - auto-dismiss timing and queueing
  - optional action button (undo/retry)
  - placement and stacking coordination
  - severity styling (info/success/warn/error)

### Navigation & Routing

- `route` ✅
  Declarative routing node that represents a navigation destination/state.
  Responsibilities:
  - defines route identity (path/name/params)
  - carries page configuration (title, transitions, guards)
  - binds to navigation system (push/pop/replace)
  Should be serializable so navigation can be restored.

- `page_nav` ✅
  Page navigation control (the “navigator UI”).
  Handles:
  - switching between pages/routes
  - back/forward behavior (if supported)
  - page transition coordination
  Commonly paired with sidebars, tab bars, or breadcrumb systems.

- `page_stepper` ✅
  Multi-step navigation component for guided flows.
  Great for:
  - onboarding
  - setup wizards
  - checkout-style sequences
  Should support:
  - step validation/locking
  - next/previous controls
  - step indicators and completion states
  - optional branching logic for advanced flows

### Progress & Lightweight Insight

- `progress` ✅
  A reusable progress presentation control.
  Supports:
  - determinate progress (0–100%)
  - indeterminate spinner/loop
  - labeled progress states (“Downloading…”, “Indexing…”, etc.)
  Should integrate with:
  - async actions
  - Terminal execution states
  - loading skeleton patterns

- `spark_plot` ✅
  Compact micro-visualization for quick trends.
  Used for:
  - dashboard cards
  - “last 7 days” trend previews
  - inline analytics
  Must be lightweight, fast to render, and readable at small sizes.

- `bar_plot` ✅
  Bar-style plotting control (often simpler and more compact than a full chart).
  Useful for:
  - tiny distribution previews
  - mini histograms
  - compact comparisons
  Should support:
  - tooltips
  - simple labels
  - optional normalization

### Layout & Composition

- `split_pane` ✅
  Resizable split layout system.
  Essential for desktop-style apps (editors, IDEs, Studio-like tools).
  Responsibilities:
  - horizontal or vertical split
  - draggable divider with constraints (min/max sizes)
  - persistence (remember split ratio)
  - optional multi-split (nestable panes)
  This is the backbone of “professional tool” layouts.

- `align` ✅
  Alignment control for positioning a child inside available space.
  Used heavily as glue:
  - aligning overlays
  - anchoring tooltips
  - placing badges/icons in corners
  Should cooperate with responsive rules and safe areas.

### Data Display & Structured Content

- `table_view` ✅
  Structured table renderer for datasets.
  Supports:
  - columns/rows with typed cells
  - sorting and basic filtering (optional)
  - row selection (single/multi)
  - virtualization for large tables
  - sticky headers (optional)
  Used for “real software” screens: logs, downloads, settings lists, analytics.

- `accordion` ✅
  Expand/collapse container for grouped content.
  Designed for:
  - settings sections
  - FAQs
  - inspector groups
  Should support:
  - single-open or multi-open behavior
  - smooth expand animations
  - header actions (icons, toggles)

### Action Surfaces & Async UX

- `action_bar` ✅
  A horizontal command strip for high-priority actions.
  Common in:
  - editor toolbars
  - selection contexts (“3 items selected”)
  - bottom action areas in mobile layouts
  Should support:
  - primary/secondary grouping
  - overflow handling (“…” menu)
  - disabled state logic tied to selection/validation

- `async_action_button` ✅
  A button specialized for async tasks.
  Must handle the full lifecycle:
  - idle → loading → success/failure
  - disables double-click execution
  - optional inline progress indicator
  - optional “retry” affordance on failure
  A small control that dramatically improves UX consistency.

### Tooling Panels (Editor-Grade UI)

- `adjustment_panel` ✅
  A panel for controlling continuous adjustments (sliders/knobs/toggles).
  Used for:
  - image/video/audio adjustments
  - theme tweaking (hue, blur, intensity)
  - tool settings (brush size, smoothing)
  Should support:
  - grouped controls
  - reset-to-default per group
  - fine-grained numeric input

- `brush_panel` ✅
  Specialized panel for brush-based tools.
  Designed for:
  - drawing/painting
  - masking
  - sculpt/erase workflows
  Typical controls:
  - size
  - hardness/softness
  - opacity/flow
  - blend mode / brush type
  Often paired with `canvas` and effects.

- `bounds_probe` ✅
  Debug/inspection utility that measures layout bounds.
  Useful for:
  - visual debugging (hitboxes, padding, alignment)
  - editor tooling (“why is this clipping?”)
  - responsive diagnostics
  Should be optional and low-overhead when disabled.

### Attachments & Media Tiles

- `attachment_tile` ✅
  A tile representation for attachments (files/media).
  Used in:
  - chat attachments
  - upload queues
  - document lists
  Should support:
  - preview icon/thumbnail
  - filename + metadata (size/type)
  - actions (open/download/remove)
  - progress indicator when uploading/downloading

- `audio` ✅
  Audio presentation/control surface.
  Can be:
  - lightweight player (play/pause, seek)
  - waveform preview
  - metadata display (duration, codec)
  Often paired with Gallery and attachments.

### Web & Rendering Surfaces

- `webview` ✅
  Embedded web content renderer.
  Used for:
  - documentation pages
  - embedded tools (web apps inside desktop)
  - OAuth/login flows (careful)
  Should handle:
  - navigation policies (allowed domains)
  - sizing and focus
  - message bridge (optional) for JS ↔ app communication

- `canvas` ✅
  Custom drawing surface for procedural or tool-driven rendering.
  Used for:
  - editors (Studio canvas, brush tools)
  - visual effects previews
  - custom graphs/plots
  Should support:
  - high-DPI rendering
  - input events (pointer/gesture)
  - optional layers (selection overlays, guides)
  and should integrate with motion/effects when needed.

### Meta: Artifact UI Integration

- `artifact_card` ✅
  A structured card component for presenting “artifacts” (generated outputs, files, exports, results).
  Intended for:
  - showing an output preview (image/text/file)
  - metadata (name, size, created time)
  - actions (open, copy, export, pin)
  This is especially useful in AI workflows (chat results, generated assets, build outputs).

### Layout & Positioning Utilities

- `center`
  Alignment wrapper that positions its child in the exact center of available space.
  Unlike raw alignment primitives, this control is intended for:
  - empty states
  - loading screens
  - hero sections
  - modal content
  Should respect responsive rules and safe-area constraints.

- `flex_spacer`
  Flexible spacing element designed for flex-style layouts.
  Used to:
  - push elements apart in toolbars
  - distribute space dynamically
  - maintain proportional spacing
  Unlike static `spacer`, this is ratio-aware and participates in layout negotiation.

- `frame`
  Structural boundary wrapper.
  Used to:
  - visually isolate components
  - simulate device frames (previews)
  - create window-like containers
  May support:
  - resizable bounds
  - border + shadow presets
  - title/header slot

### Lists, Chips & Selection UX

- `check_list`
  Structured checklist component.
  Designed for:
  - task lists
  - configuration options
  - multi-select states
  Supports:
  - grouped sections
  - indeterminate states
  - validation hooks

- `chip`
  Compact interactive element used for:
  - tags
  - filters
  - selected values
  Should support:
  - removable mode
  - toggle mode
  - icon prefix/suffix
  - disabled and active states

- `context_action_bar`
  Context-sensitive action strip.
  Appears when:
  - items are selected
  - a special state is active
  Provides:
  - bulk actions
  - contextual tools
  - quick operations
  Should auto-hide when context disappears.

### Numeric & Data Controls

- `count_stepper`
  Increment/decrement numeric control.
  Used for:
  - quantity input
  - pagination size
  - numeric adjustments
  Should support:
  - min/max constraints
  - press-and-hold acceleration
  - manual text override

- `data_source_view`
  Structured display of connected data source.
  Used for:
  - showing API endpoints
  - database connections
  - file sources
  Can display:
  - status (connected/disconnected)
  - metadata
  - refresh/reconnect actions

- `details_pane`
  Side panel for displaying contextual details.
  Often paired with:
  - table_view
  - gallery
  - explorer
  Should support:
  - collapsible sections
  - editable fields
  - action footer

### Drag & Drop System

- `drag_handle`
  Visual affordance for draggable items.
  Usually:
  - small icon/grip
  - visible on hover
  - indicates reorder capability

- `drag_payload`
  Structured object describing what is being dragged.
  Contains:
  - type identifier
  - metadata
  - source reference
  Enables safe drop validation.

- `drop_zone`
  Target area for drop operations.
  Should support:
  - hover highlight
  - validation feedback (allowed/denied)
  - insertion indicators (before/after/inside)

This trio (`drag_handle`, `drag_payload`, `drop_zone`) forms a clean drag architecture.

### Cropping, Curves & Editing Tools

- `crop_box`
  Interactive cropping overlay.
  Used for:
  - image editing
  - video trimming
  - preview selection
  Supports:
  - resizable bounds
  - aspect ratio lock
  - snap-to-grid
  - live dimension display

- `curve_editor`
  Interactive curve manipulation control.
  Used for:
  - animation easing curves
  - color correction curves
  - volume automation
  Supports:
  - draggable control points
  - bezier handles
  - grid snapping
  - preset curve selection

- `flow_field`
  Procedural motion visualization.
  Represents:
  - directional vector fields
  - motion simulations
  - animated background movement
  Can be used for:
  - advanced UI effects
  - tool previews
  - experimental visuals

### Navigation & Breadcrumb Systems

- `crumb_trail`
  Lightweight breadcrumb-style navigation.
  Designed for:
  - file paths
  - nested settings
  - hierarchical explorers
  Should support:
  - clickable segments
  - overflow handling
  - truncation for deep paths

### Buttons & Interaction Variants

- `elevated_button`
  A button variant with elevation and depth.
  Designed for:
  - primary calls-to-action
  - emphasis areas
  Supports:
  - elevation animation on hover
  - shadow token integration
  - disabled/pressed states

- `focus_anchor`
  Invisible or subtle anchor point used to manage focus.
  Used for:
  - keyboard navigation
  - accessibility flows
  - scroll-to-focus patterns
  Important for building accessible, keyboard-first apps.

### Filters & Drawers

- `filter_drawer`
  Slide-out panel dedicated to filtering options.
  Often paired with:
  - Gallery
  - table_view
  - dashboards
  Supports:
  - grouped filters
  - reset/apply controls
  - persistent open/close state

### Cursor & Interaction Feedback

- `cursor`
  Custom cursor control.
  Enables:
  - pointer style overrides
  - custom hover cursors
  - tool-specific cursors (brush, crosshair)
  May support:
  - animated cursor visuals
  - context-aware switching

### Download & Transfer

- `download_item`
  UI representation of a downloadable resource.
  Displays:
  - progress
  - speed
  - file size
  - status (queued/downloading/complete/failed)
  Integrates with progress and async systems.

### Folding & Layering

- `fold_layer`
  Layer that visually “folds” or collapses content.
  Used for:
  - advanced reveal animations
  - layered UI transitions
  - creative folding interactions
  Must integrate with animation + transition tokens.

### Field Grouping

- `field_group`
  Logical grouping container for related form fields.
  Supports:
  - label/header
  - validation summary
  - collapsible sections
  - layout alignment
  Used heavily in forms and adjustment panels.

### Gesture & Interaction Regions

- `gesture_area`
  High-level interaction capture zone.
  Designed for:
  - drag gestures
  - pinch/zoom
  - swipe detection
  - long press
  - multi-pointer interaction
  Responsibilities:
  - normalize pointer/touch/mouse events
  - prevent gesture conflicts
  - emit structured gesture events
  Often paired with canvas, editors, and complex layouts.

- `hover_region`
  Dedicated hover-detection wrapper.
  Used for:
  - tooltips
  - contextual buttons
  - hover highlights
  Should:
  - debounce rapid enter/exit
  - expose hover state for animation
  - integrate with cursor control

- `cursor`
  (Previously defined) but often integrated here —
  used to dynamically change cursor style inside gesture areas.

### Icon & Glyph Systems

- `glyph`
  Low-level symbolic rendering control.
  Represents:
  - icon glyphs
  - vector symbols
  - symbolic UI markers
  Should support:
  - font-based glyphs
  - vector paths
  - token-based sizing and color

- `glyph_button`
  Minimalist symbolic button built around glyph.
  Designed for:
  - toolbar icons
  - close buttons
  - quick actions
  Should support:
  - hover/press feedback
  - tooltip integration
  - accessibility labeling

- `icon_button`
  Higher-level button specialized for icon-only interaction.
  May include:
  - badge overlay
  - toggle state
  - focus ring

- `icon_picker`
  Selection UI for choosing icons.
  Supports:
  - searchable icon sets
  - categorized groups
  - live preview
  Should integrate with Skins icon tokens.

### Grid & Guides

- `grid`
  Structured layout grid system.
  Used for:
  - dashboards
  - responsive design layouts
  - design tooling
  Should support:
  - fixed columns
  - fluid columns
  - snapping integration
  - optional debug grid overlay

- `guides_manager`
  Visual alignment guide system.
  Used in editors (Studio-like workflows).
  Supports:
  - vertical/horizontal guides
  - snapping to guides
  - guide creation/removal
  - persistent layout memory

### Histogram & Data Visualization

- `histogram_view`
  Statistical distribution visualization.
  Used for:
  - image analysis
  - analytics dashboards
  - performance metrics
  Must support:
  - bin control
  - dynamic scaling
  - overlay lines (optional)

- `histogram_overlay`
  Overlay version of histogram.
  Used on top of:
  - images (brightness analysis)
  - charts
  - canvas
  Should remain semi-transparent and non-blocking.

- `line_plot`
  Continuous data visualization component.
  Used for:
  - analytics graphs
  - motion curves
  - real-time data feeds
  Supports:
  - smoothing
  - zoom
  - multiple lines
  - interactive inspection

### History & State Systems

- `history_stack`
  Visual representation of historical states.
  Used for:
  - undo/redo stacks
  - action logs
  - timeline previews
  Should:
  - show snapshot previews (optional)
  - indicate active state
  - integrate with editor workflows

### Layering Architecture

- `layer`
  Fundamental compositing unit.
  Used to:
  - isolate rendering
  - apply effects to subtrees
  - manage z-ordering
  Should support:
  - visibility toggling
  - blending modes
  - independent transforms

- `layer_list`
  UI representation of stacked layers.
  Designed for:
  - image editors
  - design tools
  - scene builders
  Supports:
  - reorder via drag
  - visibility toggle
  - lock state
  - thumbnail preview

- `layer_mask_editor`
  Advanced mask editing interface.
  Used for:
  - selective visibility
  - alpha masking
  - non-destructive edits
  Should support:
  - brush-based mask painting
  - gradient masks
  - preview toggling

### Advanced Morphing & Motion

- `liquid_morph`
  Organic shape transformation control.
  Used for:
  - smooth element transitions
  - blob-like UI motion
  - playful hover animations
  Must support:
  - bezier-based morphing
  - physics-based interpolation
  - token-driven duration

- `morphing_border`
  Dynamic border shape animation.
  Used for:
  - active states
  - attention highlights
  - modern interactive aesthetics
  Should:
  - animate radius and shape
  - integrate with glow/neon effects

- `motion`
  Core motion engine interface.
  Handles:
  - spring-based movement
  - curve interpolation
  - gesture-driven transforms
  - chained animation sequences
  This is the animation backbone of ButterflyUI.

### Messaging & Social UX

- `mention_pill`
  Styled inline mention component.
  Used in:
  - chat
  - comments
  - collaborative tools
  Should:
  - highlight mentioned user
  - support click-to-profile
  - adapt to theme tokens

- `message_divider`
  Structural separator inside conversations.
  Used for:
  - date breaks
  - unread markers
  - system notices

- `message_meta`
  Metadata display for messages.
  Displays:
  - timestamp
  - status (sent/read/edited)
  - author info

### Navigation Systems

- `nav_ring`
  Circular navigation interface.
  Used for:
  - radial menus
  - quick tool access
  - gaming-style UI
  Should support:
  - segment highlighting
  - keyboard shortcuts
  - animated selection

- `navigator`
  High-level navigation manager.
  Responsible for:
  - managing route stack
  - transition animations
  - state preservation
  - nested navigation contexts
  This works closely with `route` and `page_nav`.

- `info_bar`
  Informational banner strip.
  Used for:
  - warnings
  - system messages
  - contextual hints
  Should:
  - support severity levels
  - allow dismiss action
  - integrate with notification_host

### Keybinding & Input Tools

- `keybind_recorder`
  Interactive keybinding capture tool.
  Used for:
  - customizing shortcuts
  - editor configuration
  Should:
  - detect modifier combinations
  - prevent conflicts
  - display human-readable key name.

### Bars, Notices & Lightweight Messaging

- `notice_bar`
  Persistent informational bar.
  Used for:
  - system notices
  - update alerts
  - environment warnings
  Unlike `snackbar`, this is typically static until dismissed.
  Should support:
  - severity levels
  - inline actions
  - dismiss controls

- `snackbar` ✅
  Temporary transient notification.
  Used for:
  - quick feedback (“Saved”, “Copied”)
  - undo affordances
  Must support:
  - auto-dismiss timing
  - stacked behavior
  - accessibility announcements

- `reaction_bar`
  Compact reaction selector.
  Used in:
  - chat systems
  - comments
  - social features
  Supports:
  - emoji reactions
  - counters
  - hover expand behavior

### Input & Selection Controls

- `numeric_field`
  Number-specific input control.
  Must support:
  - step increment
  - validation (min/max)
  - precision control
  - optional unit display

- `option`
  Selectable option unit.
  Used inside:
  - dropdowns
  - segmented switches
  - radio groups
  Should support:
  - disabled state
  - metadata display
  - selection highlighting

- `select_option`
  Higher-level option selection control.
  Supports:
  - single or multi-select
  - search integration
  - async loading

- `path_field`
  File system path input.
  Designed for:
  - project directory selection
  - export destinations
  Should support:
  - path validation
  - browse button integration
  - auto-complete (optional)

- `pressable`
  Interaction wrapper for press gestures.
  Used when:
  - custom components need press behavior
  - ripple or animated feedback is required
  Should expose:
  - pressed state
  - hover state
  - focus state

### Layout Safety & Responsive Systems

- `safe_area`
  Layout wrapper that respects device safe zones.
  Used for:
  - mobile notches
  - system UI overlays
  - desktop window chrome
  Ensures no content is clipped.

- `scrollable_column`
  Vertical scroll container.
  Supports:
  - inertia scrolling
  - optional scrollbars
  - scroll position restoration

- `scrollable_row`
  Horizontal scroll container.
  Used for:
  - carousels
  - horizontal lists
  - tag strips

- `snap_grid`
  Alignment grid for snapping layout elements.
  Used in:
  - design tools
  - editors
  - layout builders
  Should support:
  - adjustable spacing
  - visual overlay toggle
  - snap tolerance control

- `shadow_stack`
  Layered shadow composition system.
  Allows:
  - multiple shadow layers
  - elevation blending
  - dynamic depth styling

### Navigation Systems

- `rail_nav`
  Vertical navigation rail.
  Common in:
  - desktop apps
  - dashboards
  Supports:
  - icon + label modes
  - collapsible behavior
  - active state indicator

- `segment_bar`
  Horizontal segmented navigation.
  Used for:
  - view switching
  - tab-like interaction
  Should support:
  - animated indicator
  - token-driven active styling

- `segmented_switch`
  Toggle-style segmented control.
  Designed for:
  - switching modes
  - binary/multi-state selection
  Should provide:
  - smooth animated selection transition

- `side_drawer`
  Slide-in navigation drawer.
  Used for:
  - main menu
  - contextual navigation
  Supports:
  - swipe-to-open
  - overlay scrim
  - persistent or temporary modes

- `side_panel`
  Persistent side content area.
  Often used for:
  - inspectors
  - filters
  - details panes

- `slide_panel`
  Animated sliding panel.
  Designed for:
  - temporary tool panels
  - overlays
  - progressive disclosure

### Overlays & Visual Layers

- `overlay`
  Generic overlay container.
  Used for:
  - tooltips
  - popovers
  - modal layers
  Must handle:
  - positioning
  - stacking order
  - click-outside behavior

- `progress_overlay`
  Full-screen or container-level loading overlay.
  Used during:
  - blocking operations
  - background processing
  Should:
  - prevent interaction beneath
  - show progress indicator
  - fade in/out smoothly

- `rulers_overlay`
  Overlay for measurement rulers.
  Used in:
  - design tools
  - editors
  Displays:
  - horizontal and vertical rulers
  - unit markers

- `ruler_guides`
  Interactive ruler guides.
  Supports:
  - draggable guides
  - snapping integration
  - persistent guide storage

### Data & Visualization

- `pie_plot`
  Circular data distribution chart.
  Supports:
  - labeled slices
  - hover tooltips
  - animated transitions
  - donut mode

- `rating_display`
  Visual rating component.
  Used for:
  - star ratings
  - score display
  - feedback systems
  Should support:
  - fractional values
  - hover preview

### Media & Visual Effects

- `pixelate`
  Pixelation effect layer.
  Used for:
  - blur alternative
  - censorship
  - stylized UI
  Should allow:
  - adjustable pixel size
  - animation support

- `parallax`
  Multi-layer depth illusion effect.
  Used for:
  - immersive hero sections
  - scene-based UIs
  Supports:
  - scroll-driven movement
  - pointer-based depth shift

- `ripple_burst`
  Expanding ripple animation.
  Used for:
  - press feedback
  - highlight events
  Should be performance-friendly and token-aware.

- `shimmer`
  Loading shimmer placeholder.
  Used for:
  - skeleton loading states
  - perceived performance improvement

### Reordering & Queues

- `queue_list`
  Ordered task queue visualization.
  Used for:
  - downloads
  - render queues
  - job pipelines
  Should support:
  - reordering
  - status display
  - progress integration

- `reorderable_list`
  Drag-reorderable list control.
  Supports:
  - visual insertion indicator
  - animated reflow
  - keyboard accessibility

- `reorderable_tree`
  Hierarchical drag-reorder tree.
  Used for:
  - layer systems
  - file explorers
  - nested categories
  Must support:
  - nested drop targets
  - expand/collapse
  - validation rules

### Panels & Resizing

- `resizable_panel`
  Panel with adjustable size.
  Supports:
  - drag-to-resize
  - min/max constraints
  - persisted size state
  Common in:
  - editors
  - split layouts

### Ownership & Persona

- `ownership_marker`
  Visual indicator of ownership.
  Used in:
  - collaborative environments
  - multi-user editing
  Displays:
  - user color
  - avatar badge
  - lock indicators

- `persona`
  Structured user identity component.
  Displays:
  - avatar
  - name
  - status
  Often used in chat and collaborative tools.

### Scene & Preview Systems

- `scene_view`
  High-level rendering surface for scene-based UI.
  Used for:
  - 2D/3D scene composition
  - design previews
  - animation staging
  Should support:
  - layered rendering
  - camera control (optional)
  - interactive selection

- `preview_surface`
  Lightweight rendering container for previewing:
  - components
  - assets
  - skins
  Should isolate:
  - style context
  - scaling rules
  - background

### Messaging Enhancements

- `quoted_message`
  Nested message reference block.
  Used in chat systems for:
  - reply context
  - threaded conversation
  Should visually distinguish:
  - original sender
  - excerpt text

### Structural Definitions

- `pane_spec`
  Configuration descriptor for panel layout.
  Defines:
  - initial size
  - docking rules
  - resizability
  - allowed positions

- `outline`
  Stroke styling modifier.
  Often used for:
  - focus indication
  - high contrast modes
  - selection highlighting

### Table & List Enhancements

- `sortable_header`
  Interactive table header for sortable columns.
  Designed for:
  - ascending/descending toggling
  - multi-column sort (optional)
  - visual sort indicators
  Should integrate with `table_view` and data models without mutating source data directly.

- `sticky_list`
  Scrollable list with sticky headers.
  Used for:
  - grouped datasets
  - categorized content
  - alphabetical lists
  Supports:
  - pinned group headers
  - smooth transition between groups
  - virtualization for performance

### Layout & Structural Utilities

- `spacer`
  Flexible or fixed spacing element.
  Used to:
  - maintain layout rhythm
  - enforce consistent gaps
  - participate in flex-based distribution

- `view_stack`
  Layered view container for switching between views.
  Used for:
  - tab content
  - state transitions
  - route transitions
  Should support:
  - animated crossfades
  - slide transitions
  - state preservation

- `visibility`
  Conditional rendering wrapper.
  Controls:
  - show/hide behavior
  - optional maintain-state mode
  - animated appearance/disappearance

### Input & Form Refinement

- `text_area`
  Multi-line text input control.
  Supports:
  - auto-resize
  - character limits
  - validation states
  - optional markdown support

- `text_field_style`
  Styling configuration for text inputs.
  Defines:
  - border modes
  - focus states
  - error visuals
  - label behavior
  Encourages consistent form aesthetics.

- `span_slider`
  Range-based slider with dual handles.
  Used for:
  - min/max filtering
  - timeline trimming
  - numeric ranges
  Should support:
  - tooltips
  - snapping
  - keyboard accessibility

- `time_select`
  Time-specific selection control.
  Supports:
  - hour/minute selection
  - 12h/24h formats
  - locale formatting

- `submit_scope`
  Logical wrapper that groups form submission.
  Ensures:
  - validation occurs within defined scope
  - nested forms don’t conflict
  - async submission states are isolated

### Motion & Animation Coordination

- `stagger`
  Sequential animation coordinator.
  Used for:
  - staggered list reveals
  - cascading transitions
  - delayed child animations
  Should allow:
  - configurable delay intervals
  - direction control
  - easing integration

- `tilt_hover`
  Subtle 3D tilt effect on hover.
  Used for:
  - cards
  - preview surfaces
  - interactive elements
  Should:
  - respond to pointer position
  - remain performance-aware
  - gracefully degrade on touch devices

- `time_travel`
  State navigation control.
  Designed for:
  - undo/redo navigation
  - state inspection
  - development debugging
  Should integrate with:
  - history_stack
  - timeline

### Timeline & History Systems

- `timeline`
  Chronological event visualization component.
  Used for:
  - history tracking
  - activity logs
  - editing sessions
  Should support:
  - grouped events
  - expandable entries
  - time markers
  - scrollable navigation

- `typing_indicator`
  Real-time typing feedback indicator.
  Used in:
  - chat systems
  - collaborative tools
  Should:
  - animate subtle dot or wave pattern
  - auto-hide when inactive

### Media & Rendering

- `video`
  Video rendering component.
  Supports:
  - playback controls
  - preview thumbnails
  - loop/mute modes
  - overlay controls
  Should integrate with Gallery and asset systems.

- `vector_view`
  Vector rendering surface.
  Used for:
  - SVG display
  - scalable graphics
  - icon systems
  Should:
  - preserve crisp scaling
  - support token-based coloring
  - allow dynamic path updates

- `sprite`
  Sprite rendering control.
  Used for:
  - game-like UI
  - animated icons
  - frame-based animation
  Should support:
  - sprite sheets
  - frame control
  - animation speed configuration

### Navigation & Structural Bars

- `top_bar`
  Primary top-level navigation bar.
  Typically contains:
  - app title
  - global actions
  - profile/menu
  - breadcrumb integration
  Should support:
  - sticky behavior
  - responsive collapse

- `tag_chip`
  Stylized tag element.
  Used for:
  - categorization
  - quick filters
  - status labeling
  Supports:
  - removable mode
  - clickable mode
  - token-based coloring

- `status_mark`
  Compact state indicator.
  Used for:
  - online/offline
  - synced/unsynced
  - success/error state
  Must remain visually subtle yet clear.

### Trees & Symbol Systems

- `symbol_tree`
  Hierarchical symbol explorer.
  Used in:
  - code editors
  - design tools
  - structured content browsers
  Supports:
  - expandable nodes
  - selection highlighting
  - search integration

### Viewport & Scene Management

- `viewport`
  Scroll/zoom constrained rendering window.
  Used for:
  - canvas editing
  - scene rendering
  - design previews
  Should support:
  - pan & zoom integration
  - clipping
  - transformation tracking

- `scene_view`
  (Previously defined) pairs closely with viewport for scene-level rendering.

### File & System Views

- `file_system`
  File system browser abstraction.
  Used for:
  - local file navigation
  - project browsing
  - save/load dialogs
  Should support:
  - tree + list modes
  - file metadata display
  - permission/state indicators


---

### Final Architectural Note

With this final batch, ButterflyUI now includes:

- Primitive layout and styling (Candy)
- Token-driven identity (Skins)
- Asset intelligence (Gallery)
- IDE-grade editing (CodeEditor)
- Execution tooling (Terminal)
- Visual editor environment (Studio)
- And a deep catalog of professional core controls

This is no longer a UI toolkit.

It is a layered application platform.

# Python Control Alignment List

Generated by diffing:
- Dart control dispatch cases in `butterflyui/src/lib/src/core/control_renderer.dart`
- Python schemas in `butterflyui/sdk/python/packages/butterflyui/src/butterflyui/core/schema.py`
- Python control classes in `butterflyui/sdk/python/packages/butterflyui/src/butterflyui/controls/*.py`


> Note: **Candy, Gallery, Skins, Studio, CodeEditor, and Terminal** are treated as *umbrella controls*.
> Their indented entries are **submodules** that live inside the same control (one control ID, many focused parts),
> which gives tools like GitHub Copilot much richer context when you’re navigating or generating code.

---

## Belonging to the Terminal control as a whole:
### Terminal (umbrella control)

`terminal` is the **full terminal system** in ButterflyUI: it’s not just a text box — it’s a complete runtime for
**running commands/processes**, **streaming output**, **accepting input**, and **rendering terminal UX** (tabs, timeline,
log panels, progress views, etc.) in a consistent way.

Think of it the traditional way: a “terminal” is a *workbench* — command entry, a running session, output history,
and tools around it (presets, replay, logs). That’s exactly what this umbrella control provides.

Key goals:
- **One control ID**, many submodules (so the UI stays composable but the mental model stays “Terminal”).
- Strong separation of concerns: *backend execution* vs *UI rendering* vs *data mapping*.
- Built for “real apps”: multiple sessions/tabs, progress UIs, replay, and structured logs.

#### Terminal — Capabilities + Command Authoring

- `capabilities`
  Describes and exposes what the current terminal backend can do.
  Examples:
  - Does it support interactive stdin?
  - Does it support PTY-like behavior vs non-interactive execution?
  - Can it stream live output?
  - Are ANSI colors supported? Links/clickable paths? Rich events?
  This lets the UI adapt safely instead of guessing.

- `command_builder`
  A structured “command composer” layer.
  Instead of building a raw string everywhere, this module helps:
  - build commands with arguments safely (escaping/quoting rules),
  - attach environment variables / working directory,
  - define execution mode (shell vs direct exec),
  - attach metadata (labels, tags, expected output type).
  This is also where presets can plug in (preset → builds a command).

  #### Terminal — Flow + Output Shaping

- `flow_gate`
  A small but important “traffic controller” for execution flow.
  Typical responsibilities:
  - prevent accidental double-run (debounce / lock while running),
  - decide what happens when a new run starts (cancel previous? queue? parallel?),
  - enforce policies (cooldown, max concurrent jobs, permission checks),
  - route events to the right session/tab.

- `output_mapper`
  Transforms raw backend output/events into UI-friendly structures.
  Example inputs:
  - raw stdout/stderr chunks,
  - structured events (exit code, spawn, signal, error types),
  - progress events,
  - log events.
  Example outputs:
  - formatted lines with timestamps,
  - severity classification (info/warn/error),
  - linkified paths/URLs,
  - grouped “frames” for timeline/replay.
  This is the module that keeps the “terminal UI” clean and consistent.

  #### Terminal — Presets + Progress

- `presets`
  Saved / reusable command configurations.
  Typical features:
  - named presets (e.g. “Run tests”, “Build release”, “Start dev server”),
  - preset parameters (flags, target folder, profile),
  - per-project presets (stored with project) vs global presets,
  - optional UI: quick-run buttons and templates.

- `progress`
  The progress data model and event contract.
  It standardizes how long-running tasks report:
  - percent / current / total,
  - spinner/indeterminate states,
  - stages (download → extract → install),
  - status text and ETA (if available),
  - success/failure completion.
  This supports both “classic terminal prints” and “modern progress UI”.

- `progress_view`
  The UI renderer for progress events.
  It can show:
  - progress bars,
  - stage lists,
  - compact inline progress in the output stream,
  - a dedicated progress panel if the app wants it.

#### Terminal — Prompt + Input (stdin)

- `prompt`
  The “command entry” UX layer.
  Usually includes:
  - the input field,
  - history navigation,
  - auto-complete hooks (optional),
  - run/cancel buttons,
  - current working directory display,
  - shell/profile indicators.
  This is the part users interact with most.

- `stdin`
  The input stream interface for interactive programs.
  Used when a running process expects input (password prompts, REPLs, installers).

- `stdin_injector`
  A helper module to insert input programmatically.
  Useful for:
  - automation (“send ‘y’ to confirm”),
  - test harnesses,
  - replaying recorded sessions,
  - feeding input from UI widgets (buttons, macros).
  The injector should respect `capabilities` (only inject if supported).

#### Terminal — Streaming + Rendering

- `stream`
  The live output stream contract (stdout/stderr and structured events).
  This is the backbone for “real-time terminal”.
  Responsibilities often include:
  - buffering,
  - backpressure handling,
  - merging stdout/stderr (or keeping them separate with tagging),
  - emitting structured events (spawned, exited, errored).

- `stream_view`
  The UI renderer for the output stream.
  Usually handles:
  - virtualized line rendering for performance,
  - ANSI parsing/colors (if enabled),
  - selectable/copyable text,
  - clickable links/paths,
  - auto-scroll behavior with “scroll lock” when user scrolls up.

#### Terminal — Sessions + Tabs + Timeline

- `session`
  Represents a single terminal “context”.
  Think: one shell/process group with its own history, cwd, env, and output.
  Common responsibilities:
  - store run history,
  - map incoming events to this session,
  - maintain state (idle/running/failed/success),
  - attach metadata (project, label, tags).

- `tabs`
  Multi-session UI container.
  Responsibilities typically include:
  - creating/closing sessions,
  - switching active session,
  - per-tab indicators (running dot, error icon, unread output),
  - session restore on app reload.

- `timeline`
  A structured history view of what happened over time.
  Instead of only a raw scrollback, timeline can show:
  - command blocks with start/end,
  - exit codes,
  - grouped output per run,
  - progress segments,
  - errors highlighted as “events”.
  This is great for debugging and “what did I run earlier?”.

#### Terminal — Views + Workbench Composition

- `view`
  The primary “terminal surface” layout.
  This is usually the assembled UI:
  prompt + stream_view + optional panels.

- `workbench`
  The full terminal workspace composition.
  Typically includes:
  - tabs + session routing,
  - main terminal view area,
  - optional side panels (logs, progress, inspector-like views),
  - command preset toolbar / quick actions.
  If `terminal` is the engine, `workbench` is the cockpit.

#### Terminal — Backend Bridge + Execution + Logs

- `process_bridge`
  The UI ↔ backend connector for process execution.
  It abstracts platform-specific details:
  - spawn process (cmd, args, env, cwd),
  - stream stdout/stderr,
  - write to stdin,
  - terminate/cancel,
  - exit codes and error mapping.
  The rest of the terminal should rely on this so you can swap backends.

- `execution_lane`
  A dedicated lane/track for running jobs.
  Useful when you need:
  - queued jobs (“run A then B”),
  - concurrency control (max N at once),
  - job cancellation rules,
  - consistent status reporting to timeline/progress/logs.

- `log_viewer`
  Read-only UI for viewing logs (structured or plain).
  Typical use:
  - show debug logs of the terminal subsystem itself,
  - show captured logs per session/run,
  - filter by severity/source,
  - copy/export.

- `log_panel`
  A panel wrapper around the log viewer (and controls).
  Often includes:
  - filters,
  - search,
  - clear/export buttons,
  - toggles (show timestamps, show stderr, show only errors). 

---

## Belonging to the Studio control as a whole:
### Studio (umbrella control)

`studio` is the visual builder workspace of ButterflyUI.
It is the structured environment where users design, assemble, and configure UI structures visually instead of writing raw schema by hand.

Think of Studio in the traditional builder sense: 
Canvas in the center, structure on the left, properties on the right, tools on top — everything organized, deliberate, and extensible.

Studio is not just a “drag and drop tool.”
It is a controlled design runtime that:
- edits real control schemas
- maintains a structured component tree
- supports tokens, bindings, and actions
- preserves deterministic output for production use

Design principles:
- Visual editing should reflect the actual schema 1:1
- All mutations are explicit and traceable
- Selection state is central
- Layout, transform, and properties remain cleanly separated

#### Core Workspace Architecture

- `builder`
  The orchestration layer of Studio.
  Coordinates canvas, inspector, outline, and panels.
  Responsible for:
  - loading/saving project schema
  - tracking selection state
  - routing edit commands
  - undo/redo integration
  - synchronization between visual and data model

- `canvas`
  The primary visual editing surface.
  This renders the actual component tree.
  Responsibilities:
  - render live preview of controls
  - handle drag/drop placement
  - manage hit testing for selection
  - show selection overlays and guides
  - optionally simulate device/responsive layouts

- `outline_tree`
  Hierarchical tree view of the current UI structure.
  Used for:
  - selecting deeply nested elements
  - reordering children
  - visualizing layout nesting
  - quick structural navigation
  Acts as the “structural truth” of the canvas.

#### Component & Block Authoring

- `component_palette`
  Library of available controls/components.
  Usually grouped by category (layout, display, input, etc).
  Supports:
  - drag-to-canvas
  - search/filter
  - custom component registration
  - preview thumbnails or icons

- `block_palette`
  Higher-level precomposed UI blocks.
  These are reusable patterns, not primitives.
  Examples:
  - hero section
  - card grid
  - login form
  - terminal layout preset
  Blocks accelerate design while staying editable.

- `asset_browser`
  Asset management panel.
  Used for:
  - images
  - icons
  - fonts
  - local resources
  - remote assets
  Should support preview, selection, and linking to properties.

#### Selection & Transform System

- `selection_tools`
  Tools for interacting with elements on canvas.
  Examples:
  - click select
  - multi-select
  - lasso selection
  - alignment tools
  - snap toggles

- `transform_box`
  Visual overlay around selected elements.
  Handles:
  - resize handles
  - drag move
  - rotation (if supported)
  - constraint enforcement
  - snapping to grid/guides
  This should not directly mutate schema — it emits transform intents.

- `transform_toolbar`
  Quick transform controls.
  Examples:
  - numeric position/size
  - alignment buttons
  - distribute spacing
  - lock aspect ratio
  - reset transform
  Provides precise control alongside direct manipulation.

#### Inspection & Editing

- `inspector`
  The main contextual editing surface.
  Shows editable fields based on selected element.
  Responsibilities:
  - display schema fields
  - group fields logically (layout, style, behavior)
  - validate input
  - emit change events
  - support token references and bindings

- `properties_panel`
  Dedicated structured property editor.
  May separate:
  - layout properties
  - style properties
  - behavior flags
  - animation configs
  This keeps editing organized instead of overwhelming users.

- `actions_editor`
  Editor for defining interactive behavior.
  Used to:
  - attach click handlers
  - define navigation intents
  - bind triggers to commands
  - connect to terminal or backend logic
  Actions should be declarative and serializable.

- `bindings_editor`
  Data binding configuration.
  Used to:
  - bind properties to variables
  - connect to model state
  - map events to data
  - define computed values
  This is critical for making static UI dynamic.

#### Tokens & Theming Integration

- `tokens_editor`
  Editor for design tokens.
  Manages:
  - color tokens
  - spacing tokens
  - typography tokens
  - motion tokens
  - elevation/shadow tokens
  Tokens allow consistent theming and integration with Skins/Candy.

Studio should allow:
- referencing tokens instead of raw values
- previewing token changes live
- applying theme changes globally

#### Project Structure & Environment

- `project_panel`
  Project-level management.
  Handles:
  - file structure
  - schema documents
  - page navigation
  - global configuration
  - export/build options

- `responsive_toolbar`
  Controls for responsive simulation.
  Examples:
  - device presets (mobile/tablet/desktop)
  - custom width/height
  - orientation toggle
  - zoom level
  Allows designers to test layout adaptability visually.

### Architectural Philosophy of Studio

Studio is not a toy drag editor.
It is a controlled schema editor with:

- deterministic output
- separation between view-layer and data-layer
- modular editing subsystems
- structured event routing

If Terminal is the execution engine,
Studio is the construction yard.

It builds the structure that the runtime later renders faithfully.

## Additional information for Studio:

## Studio control submodules you’ll want too:

### 1) Project & Document Core

**Purpose:** open/save projects, asset references, autosave, recovery, versioning.

* Project format (JSON + binary assets folder)
* Asset registry (images/video/audio/fonts)
* Autosave + crash recovery
* Import pipeline (copy into project / link externally)

**Good pubspec packages**

* `path`, `path_provider` (paths + app dirs)
* `file_picker` (import assets / choose save locations)
* `archive` (zip projects for sharing/backups)
* `crypto` (hash assets / dedupe)
* `uuid` (stable IDs for layers/nodes/clips)
* `mime` (detect file types)
* `collection` (better data utilities)

---

### 2) Command System (Undo/Redo) + History

**Purpose:** every edit is a command; reversible; supports batching.

* Command stack
* Transaction grouping (“dragging a layer” becomes 1 undo)
* Optional: snapshotting for heavy ops

**Good pubspec packages**

* (Often you write this yourself — it’s worth it.)
* `rxdart` (optional, if you like streams for event buses)
* `logging` (structured logs)
* `stack_trace` (better error traces)

---

### 3) Editor Surface (Canvas + Layers + Selection)

**Purpose:** the “Photoshop/Elementor” feel: zoom, pan, selection, transform handles, snapping guides.

* Infinite/large canvas (world coords)
* Layer model (rect/text/image/vector/video “elements”)
* Selection, multi-select, marquee
* Transform gizmos (scale/rotate/skew)
* Snapping/grid/rulers
* Hit testing

**Good pubspec packages**

* `flutter` built-ins + `CustomPaint` (you’ll rely on this a lot)
* `vector_math` (transforms, matrices)
* `dotted_border` (selection outlines / guides)
* `pixel_snap` *or* your own snapping math (snapping is usually custom)
* For SVG: `flutter_svg` (import SVG assets, render)
* For rich text layout on canvas: `super_editor` (optional, heavy but powerful) or simpler: your own text box widget

> Real talk: a lot of “editor feel” comes from your own math + hit testing, not a magic package. Packages help, but the *Studio* control should own the interaction model.

---

### 4) Timeline Engine (Video/Audio Editors)

**Purpose:** clips, tracks, trimming, transitions, keyframes.

* Track model (video/audio/effects)
* Clip boundaries + ripple editing
* Scrubber + playhead
* Waveform previews
* Keyframe curves (position/opacity/etc)
* Proxy generation (for smooth playback)

**Good pubspec packages**

* `ffmpeg_kit_flutter` (the workhorse: transcode, probe, render, waveform generation)
* `video_player` (basic playback; sometimes enough for preview)
* `just_audio` (reliable audio playback)
* `audio_session` (proper audio focus handling)
* `wakelock_plus` (keep screen awake while rendering/recording)
* `synchronized` (locking for render queues)

**Waveforms / visualization**

* `audio_waveforms` (waveform rendering + recording helpers, depending on platform)
* Or generate waveform data via FFmpeg and draw it yourself (classic approach, very controllable)

---

### 5) Node Graph Engine (Compositor / “Creator” Apps)

**Purpose:** Blender-like shader graph, After Effects-ish compositor graph, procedural pipelines.

* Node definitions (inputs/outputs/types)
* Connections, validation, cycles rules
* Evaluation scheduler (topological sort)
* Caching (memoization)
* Graph UI (pan/zoom, ports, wires)

**Good pubspec packages**

* Graph UI is usually custom (because you’ll want *your* look)
* `vector_math` again (geometry)
* `collection` (graphs + helpers)

If you want a head start, you can search pub.dev for node editors, but most are either limited or opinionated — for a framework like ButterflyUI, building your own graph UI is often the right “old craft” move.

---

### 6) Export / Render Pipeline

**Purpose:** “Export MP4”, “Export PNG sequence”, “Export project bundle”.

* Render queue + progress
* Background worker / isolate scheduling
* Per-platform encoders (mostly via FFmpeg)
* Presets (YouTube, TikTok, lossless, etc.)

**Good pubspec packages**

* `ffmpeg_kit_flutter` (again)
* `compute` / isolates (built-in) + `pool` (optional worker pools)
* `json_annotation` + `freezed` (nice for stable project schemas)
* `isar` or `hive` (optional: cache DB for thumbnails/proxies/render history)

---

### 7) Thumbnails, Proxies, Caching

**Purpose:** smooth UX, fast scrolling, no laggy asset previews.

* Thumbnail generation (images + video frames)
* Proxy video generation (low-res edit proxies)
* Cache invalidation

**Good pubspec packages**

* `extended_image` (better image caching + advanced features)
* `cached_network_image` (if you have online assets)
* `isar` (fast local DB) or `hive` (simple)
* `path_provider` + `crypto` (cache keys)

---

### 8) Screen Recorder Module

**Purpose:** record screen + mic/system audio, save MP4/MKV, optionally overlay webcam.

* Screen capture
* Audio capture
* Muxing
* Hotkeys
* Frame drop handling

**Good pubspec packages (reality check)**

* This is the one area where Flutter packages alone often aren’t enough.
* You typically combine:

  * **platform-native capture** (Windows/macOS/Linux APIs)
  * then FFmpeg mux/transcode if needed

Still useful packages:

* `ffmpeg_kit_flutter` (muxing + encoding control)
* `hotkey_manager` (desktop hotkeys)
* `window_manager` (desktop window control, always-on-top, etc.)
* `permission_handler` (macOS permissions especially)
* For webcam preview: `camera` (mobile-focused but can help; desktop support varies)

For serious desktop capture, you’ll likely end up with **FFI plugins** (your own or community) that call:

* Windows: Desktop Duplication API / WASAPI
* macOS: ScreenCaptureKit / AVFoundation
* Linux: PipeWire/X11/Wayland paths

ButterflyUI-wise, I’d treat this as a **Studio submodule** implemented as a “native bridge provider”.

---

### 9) Keyboard/Mouse Power UX (the “pro editor feel”)

**Purpose:** shortcuts, precise nudges, ctrl/shift behavior, selection patterns.
**Good pubspec packages**

* `flutter_shortcuts` *or* roll your own mapping layer
* `hotkey_manager` (desktop global hotkeys)
* `super_hot_key` (another option; pick one and standardize)
* `two_dimensional_scrollables` (useful for timelines/grids)
* `scrollable_positioned_list` (jump-to-index in layers/timeline lists)

---

## A practical “Studio” pubspec set (starter pack)

If I had to pick a *clean* baseline that covers most Studio apps:

**Core**

* `path`, `path_provider`, `file_picker`, `uuid`, `collection`, `archive`, `crypto`, `mime`

**State/model**

* `freezed`, `json_annotation`, `json_serializable` (or just `dart:convert` if you want minimalism)
* `isar` (or `hive`) for caches

**Editor surface**

* `vector_math`, `flutter_svg`, `extended_image`

**Media (video/audio)**

* `ffmpeg_kit_flutter`
* `video_player`
* `just_audio`
* `audio_session`
* `wakelock_plus`

**Desktop pro-feel**

* `window_manager`
* `hotkey_manager`
* `permission_handler` (especially macOS)

That combo gets you *shockingly far*.

---

## Studio control structure inside ButterflyUI (how I’d modularize it)

Think “engine + views”, old-school and dependable:

* `studio_core/`

  * `project/` (load/save, assets, autosave)
  * `commands/` (undo/redo)
  * `selection/` (hit testing, selection state)
  * `transform/` (matrix transforms, snapping)
  * `render/` (export queue, progress, presets)
  * `cache/` (thumb/proxy caches)
* `studio_surfaces/`

  * `canvas_surface/` (element editor)
  * `timeline_surface/` (tracks/clips/keyframes)
  * `node_surface/` (graph editor)
* `studio_media/`

  * `ffmpeg_bridge/`
  * `playback/`
  * `waveforms/`
  * `recording/` (optional, native-bridge heavy)
* `studio_ui/`

  * toolbars, inspectors, panels, docks
  * property editors (numbers/colors/curves)
* `studio_integrations/`

  * ButterflyUI “Candy” theming hooks
  * plugin API (custom tools/effects/elements)

That lets you build:

* **Image editor:** mostly `canvas_surface + export`
* **Elementor-like builder:** `canvas_surface + inspector + snapping + templates`
* **Video editor:** `timeline_surface + ffmpeg_bridge + cache`
* **Node compositor:** `node_surface + render`

Treat **Studio** as a **umbrella control** (a shell + runtime) and make everything else a **pluggable submodule** that registers capabilities, UI panels, tools, and file formats.

Think of it like the old-school IDE architecture: **core services + plugins**, not one giant app.

Here’s the structure I’d ship.

---

## The Studio Control: what it *is*

**`studio`** = a container control that provides:

1. **Docking layout + panels**
2. **Shared editor services** (project, assets, selection, undo/redo, commands)
3. **A plugin bus** (submodules register tools, surfaces, exporters, inspectors)
4. **Theme + UX hooks** (Candy/Skins integration)
5. **Serialization contract** (project schema + per-module state)

Users then pick submodules like LEGO.

---

## Studio’s “Core Services” (mandatory)

These are the parts every studio-like tool needs, no matter what it becomes.

### A) Project Service

* Load/save
* Autosave + recovery
* Project manifest (modules enabled, versions, assets index)

### B) Asset Service

* Import/copy/link assets
* Thumbnail/proxy caches
* File watchers (optional)

### C) Command Service (Undo/Redo)

* Command stack
* Transactions (group commands during drag)
* Command routing (active surface gets first dibs)

### D) Selection & Focus Service

* Active document, active surface, active element(s)
* Multi-select
* Focus tracking (what receives shortcuts)

### E) Tool Service

* Tool registry (“Move”, “Trim”, “Pen”, “Text”, “Cut”)
* Tool lifecycle: activate/deactivate, cursor, overlays

### F) Shortcut Service

* Keymaps (default + user override)
* Context-sensitive shortcuts (timeline vs canvas vs node graph)

### G) Render/Export Service

* Export presets + queue
* Background execution + progress callbacks

### H) Panel/Dock Service

* Panels register themselves: Inspector, Layers, Timeline, Nodes, Assets, History
* Dock layout save/restore

That’s the Studio “operating system”.

---

## Studio Submodule Types (the plugin interface set)

To make this truly configurable, don’t just have “modules”. Have **module roles**:

### 1) Surface Modules (main work areas)

Examples: Canvas editor, Timeline editor, Node graph editor, Code editor.
They provide:

* A widget/view
* Hit-testing + selection logic (or use shared)
* Tool overlays (guides, handles)
* Commands they emit

### 2) Tool Modules

Examples: Brush tool, Trim tool, Crop tool, Razor tool.
They provide:

* Input handling (mouse/key/touch)
* Command generation (for undo/redo)
* Optional UI (tool options panel)

### 3) Panel Modules

Examples: Inspector, Assets browser, Layers list, History, Export panel.
They provide:

* Dockable UI panel
* Bindings to services

### 4) Asset Handler Modules

Examples: SVG importer, PSD importer, video importer, font loader.
They provide:

* “Can I import this file?”
* Import pipeline (copy/link + metadata extraction)
* Thumbnail generation hooks

### 5) Renderer/Exporter Modules

Examples: PNG exporter, MP4 exporter via FFmpeg, GIF exporter.
They provide:

* Export formats + settings UI
* Render implementation + progress

### 6) Codec/Compute Modules (optional heavy hitters)

Examples: FFmpeg bridge, waveform generation, proxy generation.
They provide:

* Background tasks
* Job queue integration

### 7) Template/Component Modules (Elementor-like builders)

Examples: blocks library, widgets library, layout templates.
They provide:

* “Insertable” components
* Parameter schemas for inspector editing

This is how users can assemble: “I want an Elementor-like builder” (Canvas surface + Inspector + Blocks library + HTML exporter), or “Video editor” (Timeline surface + FFmpeg compute + MP4 exporter + waveform module).

---

## The “Studio Manifest” (how users choose submodules)

Users need a single config object.

Example conceptual manifest (not code, just the idea):

* enabledSurfaces: `canvas`, `timeline`
* enabledPanels: `assets`, `inspector`, `layers`, `history`
* enabledTools: `select`, `move`, `crop`, `trim`
* importers: `image`, `svg`, `audio`, `video`
* exporters: `png`, `mp4`
* compute: `ffmpeg`, `proxies`

You can store this inside the project file too, so a project can “bring its own studio setup”.

---

## Pubspec packages that support this modular Studio host

### Core + architecture

* `collection`, `meta`, `uuid`
* `path`, `path_provider`
* `file_picker`
* `archive`, `crypto`, `mime`
* `logging`

### Data model + serialization

Pick one style:

* “Batteries”: `freezed`, `json_annotation`, `json_serializable`
* “Minimal”: just `dart:convert` + careful schemas

### Caching / database (optional but very useful)

* `isar` (fast + structured) **or** `hive` (simple)

### Desktop UX (if Studio targets desktop seriously)

* `window_manager` (window controls)
* `hotkey_manager` (global hotkeys)
* `permission_handler` (macOS permissions)

### Graphics / canvas helpers

* `vector_math` (transforms)
* `flutter_svg` (SVG assets)
* `extended_image` (image caching + advanced features)

### Media stack (only if user enables video/audio modules)

* `ffmpeg_kit_flutter` (export/transcode/probes)
* `video_player` (preview playback)
* `just_audio` + `audio_session` (audio preview)
* `wakelock_plus` (render/record)

> Key idea: **Studio’s pubspec can include everything**, but submodules are “soft-enabled” by manifest. Or, if you want lean builds: you split submodules into separate Dart packages later.

---

## How to design the plugin API (so it stays clean)

Use a “registry” approach:

### Studio provides registries:

* `SurfaceRegistry`
* `ToolRegistry`
* `PanelRegistry`
* `ImporterRegistry`
* `ExporterRegistry`
* `CommandRegistry` (optional)
* `SchemaRegistry` (inspector uses this)

### Each module implements:

* `id`, `version`, `dependsOn`
* `register(StudioHost host)` where it adds its parts

And you keep dependencies honest:

* Timeline module can depend on FFmpeg module
* Screen recorder depends on platform capture module

Old-school, predictable, maintainable.

---

## The 3 Studio “starter kits” you should ship

So users can start instantly:

### 1) StudioKit.CanvasBuilder (Elementor-ish)

* Surfaces: Canvas
* Panels: Assets, Inspector, Layers, History
* Tools: Select/Move/Resize/Text/Shapes
* Importers: PNG/JPG/SVG/Fonts
* Exporters: PNG/SVG/HTML (later)

### 2) StudioKit.VideoEditor

* Surfaces: Timeline + Preview
* Panels: Assets, Inspector, Effects, Export, History
* Tools: Trim/Razor/Move/Snap
* Compute: FFmpeg, Waveforms, Proxies
* Exporters: MP4/GIF

### 3) StudioKit.NodeComposer

* Surfaces: NodeGraph + Preview
* Panels: Node library, Inspector, History
* Tools: Connect/Group/Frame
* Exporters: PNG sequence / MP4 (if FFmpeg enabled)

These kits are your “classic presets”, like how old software ships templates.

---

## One important warning (so you don’t get stuck later)

If you want Studio to be truly universal, **don’t hardcode “layers” or “clips”** as the only content types.

Instead define a generic concept:

* **Entity** (anything editable)
* **Component** (properties)
* **Surface view** (how entities are visualized/edited)

That’s the trick that lets the same inspector edit:

* a canvas rectangle,
* a timeline clip,
* a node parameter,
* a recorded capture source.

---

## Belonging to the CodeEditor control as a whole:
## CodeEditor (umbrella control)

`code_editor` is the full IDE surface of ButterflyUI.
It is a Monaco-powered editing environment wrapped inside a modular, dockable workbench architecture.

This is not just an editor widget.
It is a structured developer workspace that includes:

- Monaco editing surface
- Multi-file tab system
- Explorer tree
- Smart search (text + semantic)
- Diff viewer
- Diagnostics pipeline
- Docking system
- Command routing
- Workspace orchestration

Design goals:
- Monaco as the core editing engine
- Clean separation between document model and UI state
- Intent-driven command routing
- Fully modular dock/workbench system
- Replaceable backend services (search, diagnostics, etc.)

If Studio builds UI,
CodeEditor builds logic.

### Core Editor Surface

- `editor_surface`
  The Monaco integration layer.
  Handles:
  - editor instance creation
  - theme configuration
  - language registration
  - editor options (tab size, minimap, word wrap)
  - event forwarding (cursor change, content change, focus)

- `editor_view`
  The visual container that hosts `editor_surface`.
  Responsible for:
  - layout constraints
  - focus management
  - integration into dock panes
  - editor lifecycle control

- `editor_minimap` / `mini_map`
  Visual overview of the current document.
  Syncs with Monaco's minimap but can:
  - toggle visibility
  - provide hover previews
  - support custom overlays (errors, markers)

- `gutter`
  Side column next to the editor.
  Used for:
  - line numbers
  - breakpoints
  - diagnostics markers
  - git change indicators

- `hint`
  Lightweight contextual suggestion element.
  Used for:
  - inline hints
  - tooltips
  - completion explanations

- `inline_widget`
  Small UI widgets embedded inside the editor.
  Examples:
  - inline buttons
  - refactor actions
  - small status badges

- `ghost_editor`
  Lightweight overlay editor used for:
  - preview edits
  - AI suggestions
  - temporary transformations
  Should not mutate the main document until confirmed.

### Document & Buffer Architecture

- `code_buffer`
  The raw text state container.
  May wrap Monaco model or mirror it.
  Responsibilities:
  - store text
  - track dirty state
  - versioning
  - change tracking

- `code_document`
  Higher-level representation of a file.
  Contains:
  - file path
  - language mode
  - metadata
  - diagnostics
  - buffer reference

- `code_category_layer`
  Logical classification layer.
  Used for:
  - grouping files (source/tests/config)
  - tagging documents
  - contextual behavior (lint rules per category)

- `document_tab_strip`
  UI layer for open document tabs.
  Handles:
  - dirty indicators
  - close actions
  - tab reordering
  - pinned tabs

### Tabs, Workspace & IDE Shell

- `editor_tabs`
  Tab container for editor instances.
  Supports:
  - multiple open editors
  - split views
  - tab grouping

- `file_tabs`
  Tab container specifically tied to filesystem documents.

- `ide`
  High-level shell container.
  Combines:
  - explorer
  - editor area
  - panels
  - command bar
  - dock system

- `workbench_editor`
  Layout coordinator for the IDE.
  Responsible for:
  - docking regions
  - panel visibility
  - restoring layout state

- `workspace_explorer`
  Root-level workspace navigator.
  Supports:
  - multiple folders
  - project roots
  - virtual workspaces

- `file_tree`
  Filesystem tree view.
  Allows:
  - open file
  - rename
  - delete
  - drag/drop reorder (if virtual)

- `explorer_tree`
  Generic tree used for structured navigation.
  Can represent:
  - symbols
  - document outline
  - workspace items

- `tree`
  Shared tree primitive used across explorer-style views.

### Search System (Text + Semantic)

- `smart_search_bar`
  Unified search entry.
  Can interpret:
  - file paths
  - commands
  - symbols
  - raw text queries

- `search_box` / `search_field`
  Basic input component for search queries.

- `search_intent`
  Structured representation of a search request.
  Includes:
  - query
  - scope
  - flags (regex, case-sensitive)
  - provider target

- `search_provider`
  Pluggable search backend.
  Can be:
  - text search
  - symbol search
  - semantic search
  - command search

- `semantic_search`
  AI-assisted search layer.
  Used for:
  - natural language queries
  - context-aware file lookup
  - related code suggestions

- `search_scope_selector`
  Defines where search applies:
  - current file
  - open files
  - workspace
  - specific folder

- `search_source`
  Defines which provider supplies results.

- `query_token`
  Structured token inside advanced queries.
  Example:
  - `lang:python`
  - `ext:.dart`
  - `in:comments`

- `search_results_view`
  Virtualized results list.
  Shows:
  - file path
  - preview snippet
  - match highlights

- `search_everything_panel`
  Global command-style search panel.
  Similar to “Ctrl+P / Command Palette”.

- `search_history`
  Stores previous queries for quick reuse.

- `command_search`
  Search provider specialized for command palette behavior.

### Diff & Comparison

- `diff`
  Monaco diff integration layer.
  Responsible for:
  - side-by-side comparison
  - inline diff mode
  - tracking original vs modified models

- `diff_narrator`
  Human-readable explanation of changes.
  Can:
  - summarize edits
  - describe added/removed sections
  - support AI explanations

### Diagnostics & Errors

- `diagnostic_stream`
  Event stream for diagnostics.
  Receives:
  - lint results
  - type errors
  - warnings
  - runtime analysis results

- `diagnostics_panel`
  Structured list view of diagnostics.
  Supports:
  - filter by severity
  - click-to-navigate
  - grouping by file

- `inline_error_view`
  Renders error markers directly in editor.

### Docking & Layout System

- `dock`
  Docking container manager.

- `dock_pane`
  Individual pane within dock layout.

- `dock_graph`
  Internal structure describing dock relationships.
  Manages:
  - split orientation
  - active panes
  - layout persistence

- `empty_state_view` / `empty_view`
  Placeholder UI when no document is open.

### Command & Intent System

- `editor_intent_router`
  Routes structured editor commands.
  Example:
  - open file
  - close tab
  - format document
  - go to definition

- `intent_router`
  Generic routing layer used across workbench.

- `intent_panel`
  UI for displaying and triggering available intents.

- `intent_search`
  Allows searching through available intents.

- `command_bar`
  Quick command execution bar (similar to VS Code command palette).

### Export & External Actions

- `export_panel`
  Panel for exporting:
  - file
  - project
  - diff
  - bundle
  Can integrate with Terminal for build/export pipelines.

### Architectural Philosophy

CodeEditor is:

- Monaco at the core
- Intent-driven
- Dockable and modular
- Backend-agnostic (search, diagnostics, AI)
- Workspace-aware
- Designed for scale

If Terminal executes,
and Studio constructs UI,
CodeEditor engineers logic.

---

## Belonging to the Skins control as a whole:
## Skins (umbrella control)

`skins` is the visual identity system of ButterflyUI.

It defines how the entire application looks and behaves stylistically:
colors, materials, effects, typography, motion, interaction feedback, and responsive behavior.

Skins is not a simple theme toggle.
It is a structured, token-driven styling engine designed to:

- Centralize visual configuration
- Support multiple skin profiles
- Allow runtime switching
- Keep styling deterministic and serializable
- Separate design from logic
- Integrate deeply with Candy + Studio

If Candy provides styling primitives,
Skins defines the rules and values that drive them.

### Core Skin Management

- `skins`
  Root orchestrator of the skin system.
  Responsibilities:
  - manage available skins
  - load/save skin configurations
  - broadcast skin updates
  - provide resolved tokens to runtime
  - ensure consistent application-wide styling

- `selector`
  UI for choosing the active skin.
  Supports:
  - list/grid of skins
  - preview thumbnails
  - metadata display (author, version, description)
  - quick switch

- `preset`
  Built-in skin template.
  Used to:
  - provide starting points (Dark, Light, Glass, Neon, Minimal)
  - enforce structured defaults
  - speed up creation workflow

- `create_skin`
  Entry workflow for creating a new skin.
  Can:
  - clone from preset
  - clone from existing skin
  - create from blank template

- `edit_skin`
  Load an existing skin into the editing system.

- `delete_skin`
  Remove a skin configuration (with safety confirmation).

- `apply`
  Apply the selected skin to the runtime.
  Should:
  - propagate resolved tokens
  - refresh UI
  - trigger transition animations (if enabled)

- `clear`
  Reset editing state or revert to default values.

### Token System & Mapping

- `token_mapper`
  Core transformation engine that converts raw skin configuration
  into resolved runtime tokens.

  Responsibilities:
  - resolve token inheritance
  - compute derived values (e.g., hover color from base color)
  - apply responsive variants
  - provide fallback values
  - validate token types

Tokens may include:
- color tokens
- spacing tokens
- typography tokens
- radius tokens
- motion tokens
- elevation tokens

Skins should avoid raw values in UI controls —
everything should resolve through tokens.

### Visual Foundations

These define the raw visual building blocks used by Candy.

- `colors`
  Defines:
  - primary/secondary/accent
  - background/surface variants
  - success/warning/error
  - text hierarchies
  - semantic states (hover, pressed, disabled)

- `fonts`
  Controls:
  - font families
  - weight scale
  - heading/body scale
  - line height
  - letter spacing

- `icons`
  Icon pack configuration.
  Defines:
  - icon family
  - stroke thickness
  - fill mode
  - scaling rules

- `background`
  Global surface backgrounds.
  May support:
  - gradients
  - textures
  - layered backgrounds
  - image-based backgrounds

- `border`
  Border styling tokens:
  - thickness
  - radius
  - style (solid/dashed/etc.)
  - color mapping

- `shadow`
  Elevation model.
  Defines:
  - shadow levels
  - softness
  - spread
  - blur
  - color tint

- `outline`
  Stroke styling.
  Often used for:
  - focus rings
  - accessibility indicators
  - high contrast modes

### Advanced Visual Systems

These push Skins beyond basic theming.

- `materials`
  Defines surface material behavior.
  Examples:
  - glassmorphism
  - acrylic blur
  - matte
  - neon glow
  - metallic finishes
  Materials can combine:
  - blur
  - transparency
  - noise
  - reflection overlays

- `effects`
  Visual modifiers that can apply globally or per component.
  Examples:
  - glow
  - blur
  - grain
  - noise
  - bloom
  - chromatic aberration

- `particles`
  Particle systems for visual flair.
  Examples:
  - background sparkle
  - hover bursts
  - animated gradients
  Should remain optional and performance-aware.

- `shaders`
  GPU-level styling.
  Used for:
  - animated backgrounds
  - distortion
  - custom rendering effects
  Must be isolated and safe to disable on low-power systems.

### Motion & Interaction

- `animation`
  Defines animation behavior globally.
  Controls:
  - duration scale
  - easing curves
  - spring configs
  - motion density
  Ensures consistent motion language.

- `transition`
  Governs state transitions:
  - hover transitions
  - page transitions
  - modal open/close
  - skin switching animation

- `interaction`
  Interaction feedback styling:
  - hover effects
  - pressed effects
  - ripple effects
  - focus visuals
  - drag indicators

This ensures consistent UX across all controls.

### Layout & Responsiveness

- `layout`
  Defines:
  - default spacing scale
  - grid systems
  - alignment defaults
  - container behavior
  - default padding/margins

- `responsive`
  Controls:
  - breakpoints
  - adaptive scaling
  - font scaling
  - layout overrides per size
  - mobile vs desktop behavior

### Editing Systems

Each visual subsystem has a dedicated editor to prevent chaos.

- `editor`
  Main editing surface wrapper.

- `effect_editor`
  Configure visual effects.

- `particle_editor`
  Configure particle behavior.

- `shader_editor`
  Configure shader parameters.

- `material_editor`
  Configure surface material layers.

- `icon_editor`
  Configure icon family + styling.

- `font_editor`
  Configure typography system.

- `color_editor`
  Configure palette + semantic colors.

- `background_editor`
  Configure background layers.

- `border_editor`
  Configure border tokens.

- `shadow_editor`
  Configure elevation/shadow levels.

- `outline_editor`
  Configure outline/focus tokens.

Each editor should:
- validate input
- preview live
- update tokens
- remain modular

### Architectural Philosophy

Skins is:

- Token-driven
- Runtime-switchable
- Structured and modular
- Performance-aware
- Deeply integrated with Candy and Studio

Skins defines identity.

If Studio constructs,
and CodeEditor engineers,
Skins gives everything its visual soul.

---

## Belonging to the Gallery control as a whole:
Perfect. Gallery is more important than it looks.

This is not just a grid of images — this is your **asset intelligence layer** for ButterflyUI.
It connects media, skins, fonts, and external resources into one structured browsing and selection system.

Here is the full, detailed architectural block:

## Gallery (umbrella control)

`gallery` is the structured asset browser system of ButterflyUI.

It provides a unified interface for browsing, previewing, filtering, selecting, and applying
assets such as:

- Fonts
- Images
- Video
- Audio
- Documents
- Skins
- Presets

Gallery is not a static grid.
It is a dynamic, type-aware asset orchestration layer designed to:

- Support multiple media types
- Provide consistent preview/render behavior
- Allow filtering, sorting, and search
- Handle large datasets efficiently
- Support selection modes (single, multi, toggle)
- Integrate directly with Studio and Skins

If Skins defines identity,
Gallery supplies the resources.

### Core Gallery Architecture

- `gallery`
  Root orchestrator for the asset system.
  Responsibilities:
  - manage asset datasets
  - register asset types
  - coordinate filters and search
  - manage selection state
  - trigger apply/clear actions
  - provide type-specific renderers

Gallery should be:
- media-type aware
- extensible
- virtualized for performance
- capable of remote + local sources

### Layout & Navigation

- `grid_layout`
  Main layout engine for asset display.
  Handles:
  - responsive column count
  - spacing and alignment
  - lazy loading / virtualization
  - adaptive tile sizing

- `pagination`
  Used for large datasets.
  Supports:
  - page switching
  - page size control
  - infinite scroll mode (optional)

- `section_header`
  Group separator inside gallery.
  Used for:
  - category grouping
  - recent vs all
  - recommended sections

- `toolbar`
  Top-level action container.
  May include:
  - search
  - filter
  - sort
  - view toggle
  - bulk actions

### Search, Filter & Sorting

- `search_bar`
  Entry point for query-based filtering.
  Supports:
  - text search
  - type-aware search
  - live filtering

- `filter_bar`
  Structured filtering interface.
  Examples:
  - file type
  - tags
  - date
  - author
  - resolution
  - duration (for audio/video)

- `sort_bar`
  Sorting controls.
  Examples:
  - name (A-Z)
  - date added
  - size
  - popularity
  - custom metadata

Gallery filtering should not mutate data —
it should compute a derived filtered view.

### Item System (Tile Architecture)

Each asset is represented as a tile composed of smaller submodules.

- `item_tile` ✅
  Main asset container.
  Combines:
  - preview
  - metadata
  - selection controls
  - action buttons

- `item_preview`
  Visual representation of the asset.
  Behavior varies by type:
  - image thumbnail
  - video snapshot
  - audio waveform
  - font preview sample text
  - document icon or first page preview

- `item_meta_row`
  Metadata display.
  Can show:
  - name
  - size
  - type
  - duration
  - resolution
  - author

- `item_badge`
  Small indicator tag.
  Used for:
  - "new"
  - "premium"
  - "selected"
  - "favorite"
  - file type labels

- `item_actions`
  Inline action buttons.
  Examples:
  - preview
  - download
  - edit
  - delete
  - apply

- `item_selectable`
  Wrapper enabling selection state logic.

- `item_drag_handle`
  Enables drag-based movement of asset.

- `item_drop_target`
  Accepts dropped items for:
  - categorization
  - reordering
  - grouping

- `item_reorder_handle`
  Specific UI for manual reordering inside collections.

### Selection System

Gallery must support multiple selection strategies.

- `item_selection_checkbox`
  Multi-select via checkbox.

- `item_selection_radio`
  Single-select mode.

- `item_selection_switch`
  Toggle selection mode.

- `select_all`
  Bulk select visible items.

- `deselect_all`
  Bulk clear selection.

- `apply`
  Commit selection to calling context.
  For example:
  - apply font to Skins
  - insert image into Studio
  - assign video to background

- `clear`
  Reset current selection state.

### Media-Type Modules

Each asset type has specialized behavior.

#### Fonts

- `fonts`
  Font dataset management.

- `font_picker`
  Selection UI specialized for fonts.

- `font_renderer`
  Live preview renderer.
  Should:
  - render sample text
  - show weights/styles
  - display character sets

- `apply_font`
  Applies selected font to:
  - Skins typography
  - Studio element
  - Global theme

#### Images

- `image`
  Image asset handler.

- `image_picker`
  Image selection UI.

- `image_renderer`
  Optimized image preview.
  Should:
  - lazy load
  - handle different resolutions
  - support fallback

- `apply_image`
  Applies selected image to:
  - background
  - component
  - asset slot

- `set_as_wallpaper`
  Specialized application for:
  - global background
  - skin background layer

#### Video

- `video`
  Video asset manager.

- `video_picker`
  Video selection UI.

- `video_renderer`
  Lightweight preview:
  - thumbnail extraction
  - short looping preview (optional)
  - duration indicator

#### Audio

- `audio`
  Audio asset manager.

- `audio_picker`
  Audio selection UI.

- `audio_renderer`
  Audio preview:
  - waveform visualization
  - duration display
  - playback controls

#### Documents

- `document`
  Generic document asset handler.

- `document_picker`
  Document selection UI.

- `document_renderer`
  Preview strategy:
  - icon-based
  - first-page snapshot
  - metadata preview

### States & Feedback

- `empty_state`
  Displayed when no items are available.
  Should:
  - explain why empty
  - offer action (upload/import)

- `loading_skeleton`
  Placeholder UI while loading.
  Ensures:
  - visual continuity
  - no layout shift
  - perceived performance

### Presets & Skin Integration

- `presets`
  Predefined asset collections.
  Examples:
  - curated icon sets
  - recommended backgrounds
  - starter font bundles

- `skins`
  Direct integration with the Skins system.
  Allows:
  - browsing skins inside gallery
  - previewing skin before apply
  - applying full visual identity

### Architectural Philosophy

Gallery is:

- Type-aware
- Extensible
- Performance-conscious
- Selection-driven
- Deeply integrated with Skins and Studio
- Structured for both local and remote assets

If Studio constructs,
and Skins defines identity,
Gallery supplies the resources that bring everything to life.

---

## Belonging to the Candy control as a whole:
## Candy (umbrella control)

`candy` is the foundational styling and layout system of ButterflyUI.

It provides the primitive building blocks used by every other control:
layout containers, surfaces, typography, decoration, motion, and visual modifiers.

Candy is intentionally low-level and composable.

It is not a theme system (that is Skins).
It is not a visual builder (that is Studio).
It is not an IDE (that is CodeEditor).

Candy is the structural and visual primitive layer that all of those systems rely on.

Design goals:
- Composable layout primitives
- Deterministic rendering
- Token-driven styling (via Skins)
- Separation of structure and decoration
- Motion and interaction as first-class citizens
- Performance-aware rendering

### Core Philosophy

Candy follows a layered rendering model:

Structure → Surface → Decoration → Effects → Motion → Interaction

Each control should:
- Do one thing well
- Be stackable
- Accept tokens instead of raw style values
- Remain predictable

Candy is your “traditional craftsmanship” layer.
Clean primitives. No chaos. No magic.

## Layout Primitives

These are structural containers used everywhere.

- `row`
  Horizontal layout container.
  Responsibilities:
  - align children left-to-right
  - control spacing and alignment
  - support main/cross axis constraints
  Foundation for toolbars and inline layouts.

- `column`
  Vertical layout container.
  Used for:
  - stacked content
  - panels
  - forms
  - vertical grouping

- `stack`
  Overlay layout container.
  Children are layered on top of each other.
  Used for:
  - overlays
  - badges
  - floating elements
  - complex compositions

- `wrap`
  Flow layout.
  Automatically wraps children when space runs out.
  Ideal for:
  - tag clouds
  - responsive grids
  - chip groups

- `container`
  Single-child box with layout + style support.
  Supports:
  - padding
  - constraints
  - alignment
  - decoration
  Often the most commonly used wrapper.

- `surface`
  A styled visual surface.
  Acts as a semantic layer for:
  - cards
  - panels
  - sheets
  - backgrounds
  Should respect Skins tokens.

- `align`
  Aligns child within available space.

- `center`
  Shortcut alignment to center.

- `spacer`
  Flexible or fixed spacing element.
  Keeps layout clean and predictable.

- `aspect_ratio`
  Enforces fixed ratio for its child.
  Useful for:
  - media previews
  - thumbnails
  - responsive elements

- `overflow_box`
  Allows child to exceed parent constraints.
  Useful for:
  - pop effects
  - animated expansions

- `fitted_box`
  Scales child to fit inside constraints.

## Interactive Primitives

- `button`
  Clickable action primitive.
  Must support:
  - hover state
  - pressed state
  - disabled state
  - focus state
  - motion/transition integration
  Should derive styling from Skins tokens.

- `badge`
  Small status indicator.
  Used for:
  - counts
  - alerts
  - status flags

- `avatar`
  Profile/image representation.
  Supports:
  - circle/square shapes
  - fallback initials
  - border overlays

- `icon`
  Icon rendering primitive.
  Should support:
  - token-based size
  - color inheritance
  - animation compatibility

- `text`
  Typography primitive.
  Must:
  - use token-driven font scale
  - support semantic roles (heading, body, caption)
  - handle overflow strategies

## Decoration & Styling Modifiers

These wrap or modify visual output.

- `border`
  Stroke around element.
  Controlled via:
  - thickness
  - radius
  - color tokens

- `shadow`
  Elevation effect.
  Should use Skins elevation levels.

- `outline`
  Focus or accent stroke.
  Used for:
  - accessibility
  - selected states

- `gradient`
  Gradient background modifier.
  Can support:
  - linear
  - radial
  - animated gradients

- `decorated_box`
  Composite decoration container.
  Combines:
  - border
  - gradient
  - shadow
  - background layers

- `clip`
  Clips child to shape.
  Used for:
  - rounded corners
  - custom shapes

## Effects & Advanced Visual Layers

These enhance presentation without altering structure.

- `effects`
  Visual modifiers such as:
  - blur
  - glow
  - noise
  - bloom
  - color filters

- `particles`
  Particle rendering layer.
  Should:
  - remain optional
  - be performance aware
  - integrate with Skins tokens

- `canvas`
  Custom drawing surface.
  Used for:
  - procedural graphics
  - custom visual components
  - advanced rendering needs

## Motion & Animation

Candy treats motion as structural, not decorative.

- `animation`
  Defines animation drivers.
  Supports:
  - duration
  - easing
  - spring curves
  - chained sequences

- `transition`
  State-based animated transitions.
  Used for:
  - hover state changes
  - page transitions
  - theme switching

- `motion`
  Primitive motion system.
  Provides:
  - gesture-driven animation
  - physics-based animation
  - transform animations (scale, rotate, translate)
  Motion should be token-aware for consistency.

---

## Architectural Role in ButterflyUI

Candy is:

- The lowest visual layer
- Token-driven but token-agnostic
- Composable and predictable
- Performance-focused
- Used by every other umbrella control

---

Hierarchy of responsibility:

Candy → defines structure and primitives  
Skins → defines visual identity via tokens  
Studio → builds UI using Candy  
CodeEditor → builds logic using Candy  
Gallery → renders assets using Candy  
Terminal → renders execution surfaces using Candy  

Candy is the craft.

Everything else is built on top of it.

---

## The shared pattern for all umbrella controls:
Yep — and your LIST.md already sets the precedent: **Candy, Gallery, Skins, Studio, CodeEditor, Terminal are umbrella controls** with submodules living under one control ID. 

Below is the “extra layer” you’re asking for: how to make **Candy / CodeEditor / Terminal / Skins / Gallery** behave like **Studio** does — i.e. a **host control** where users pick submodules to assemble their own program (their own IDE, their own asset browser, their own theme editor, etc.).

---

## The shared pattern for all umbrella controls

Give every umbrella control the same 3-part architecture:

### 1) A Host (the control itself)

* Owns the **layout/workbench**
* Owns **core services**
* Owns **registries** (module registration)
* Owns **persistence** (layout + settings + module enablement)

### 2) Modules (submodules)

Each module declares:

* `id`, `version`, `depends_on`
* what it contributes: **panels**, **tools**, **views**, **providers**, **commands**
* what services it needs from the host

### 3) A Manifest (user configuration)

A serializable config that selects:

* enabled modules
* default layout
* keybinds
* providers (local/remote, etc.)

If you do this consistently, users can “compose software” the old-school way: **shell + plugins**, like classic IDEs.

---

# Candy as an umbrella control (User assembles a design language)

Candy in your doc is the primitives layer. 
To make it “user-buildable”, you don’t want users picking *every primitive*. Instead, let them pick **systems**:

## Candy module roles

### A) Foundations

* `layout_primitives` (row/column/stack/wrap/container/spacer/etc.)
* `typography` (text roles, scaling rules)
* `icons` (glyph/icon packs, sizing rules)
* `surfaces` (surface/card/panel conventions)

### B) Interaction language

* `states` (hover/pressed/focus/disabled)
* `hit_slop` and accessibility defaults
* `gesture_profiles` (desktop vs touch feel)

### C) Motion language

* `motion_engine` (springs/curves)
* `transition_pack` (page/modal/hover transitions)
* `stagger_pack` (list reveal)

### D) Effects systems (optional packs)

* `glass_pack` (blur, acrylic, noise)
* `glow_pack`
* `grain_pack`
* `particles_pack`
* `shader_pack`

### E) Composition helpers

* `style_resolver` (token lookup + variants)
* `variant_system` (intent/size/shape)
* `component_recipes` (button recipe, card recipe, input recipe)

## Candy manifest example (conceptually)

* enabledPacks: `["foundations", "interaction", "motion", "glass_pack"]`
* defaultVariant: `{ density: "comfortable", radius: "md" }`
* performanceMode: `balanced | low_power | max`

## Pubspec packages Candy often benefits from

* `vector_math` (transforms/math helpers)
* `flutter_svg` (icons/illustrations)
* `material_color_utilities` (nice token generation / tonal palettes if you want it)
* `animations` (optional helper widgets, if you want classic transitions fast)
* Effects-heavy packs might need shader plumbing (often custom), but you can keep it optional.

---

# CodeEditor as an umbrella control (Users build their own IDE)

Your LIST already describes CodeEditor as a modular workbench. 
To make it *user-assembled*, treat “IDE features” as modules you can switch on/off.

## CodeEditor module roles

### A) Workbench + Docking

* `workbench_editor` (layout coordinator)
* `dock`, `dock_pane`, `dock_graph`
* `layout_persistence` (save/restore)

### B) Document system

* `workspace_explorer`, `file_tree`
* `document_model` (buffers/docs)
* `tab_system` (tabs/splits)

### C) Language intelligence (plug-in providers)

* `diagnostics_provider` (lint/type errors)
* `formatter_provider`
* `symbols_provider` (outline tree)
* `completion_provider`
* `goto_provider` (definition/references)

This is where you can support multiple backends:

* local analyzers
* LSP
* “AI suggestions” provider
* simple regex-based fallback

### D) Search systems

* `text_search`
* `semantic_search` (optional)
* `command_palette`

### E) Dev workflows

* `diff`
* `git_integration` (optional)
* `tasks` (run/build/test) that can delegate to Terminal

## CodeEditor manifest ideas

* enabledPanels: explorer, search, diagnostics, outline, diff
* enabledProviders: lsp, formatter, semantic_search
* keymap: vscode | sublime | custom
* fileTypes: what languages are registered

## Pubspec packages that help CodeEditor feel “real”

* `flutter_inappwebview` or `webview_flutter` (if Monaco is hosted via WebView; depends on your current approach)
* `file_picker`, `path`, `path_provider`
* `watcher` (file watching)
* `hotkey_manager` (desktop shortcuts)
* `window_manager` (desktop window UX)
* `archive` (workspace export)
* For protocol/LSP: `json_rpc_2` (or your own protocol layer), `web_socket_channel` (if talking to servers)
* For diff prettiness: often custom, but `collection` helps.

---

# Terminal as an umbrella control (Users build their own “workbench terminal”)

Your Terminal section is already very plugin-friendly (sessions, tabs, output mapping, progress, etc.). 
To make it user-assembled, the key is: **multiple backends** + **multiple renderers**.

## Terminal module roles

### A) Backend bridges (swappable engines)

* `process_bridge_local` (spawn local processes)
* `process_bridge_pty` (PTY-style true terminal)
* `process_bridge_remote` (SSH / remote agent)
* `process_bridge_sandbox` (restricted command runner for “safe mode”)

### B) Output shaping + renderers

* `output_mapper_basic`
* `ansi_parser` (optional)
* `stream_view_plain`
* `stream_view_rich` (links, folding, grouping)
* `timeline_view` (structured runs)

### C) Session/workflow modules

* `tabs`
* `presets`
* `execution_lane` (queue + concurrency policies)
* `stdin_tools` (injector, macros)

### D) Extras

* `log_panel`
* `progress_view`
* `replay_recorder` (record a session and replay it)

## Terminal manifest ideas

* backend: `local | pty | remote`
* viewsEnabled: stream_view, timeline, progress, logs
* safetyPolicy: allowlist commands, block destructive commands
* concurrency: max jobs, cancel policy

## Pubspec packages that help Terminal

* `process` (or direct `dart:io` Process; package depends on your style)
* `xterm` (very useful if you want real terminal emulation rendering)
* `hotkey_manager`, `window_manager`
* `collection`, `logging`
* `synchronized` (job lanes / locking)
* `path` / `path_provider` (logs + session history persistence)

---

# Skins as an umbrella control (Users build identity systems)

Skins is already token-driven in your doc. 
To make it user-configurable like Studio, split it into **token pipelines** + **editors** + **preview surfaces**.

## Skins module roles

### A) Token pipeline

* `token_schema` (what tokens exist)
* `token_mapper` (resolve inheritance/derived values)
* `token_validator` (types, ranges)
* `token_exporters` (export to json, export to code, export to CSS-like maps)

### B) Editors (users can enable/disable complexity)

* `color_editor`
* `typography_editor`
* `motion_editor`
* `material_editor` (glass/neon/etc.)
* `effect_editor`
* `icon_editor`

### C) Preview & testing

* `preview_surface` (live sample app)
* `component_preview_gallery` (see how controls react)
* `accessibility_preview` (contrast, focus visibility)

### D) Distribution

* `skins_registry` (installed skins)
* `skins_market` (optional, if you ever want remote browsing)
* `versioning` + migrations (skin format changes)

## Skins manifest ideas

* enabledEditors: colors/fonts/motion/materials
* previewMode: minimal | full_app | component_grid
* constraints: enforce contrast, clamp motion duration, etc.

## Pubspec packages that help Skins

* `shared_preferences` (simple persistence)
* `isar` or `hive` (skin library + metadata)
* `material_color_utilities` (palette generation / tonal rules)
* `collection`, `uuid`
* Optional: `color_models` (if you want advanced color spaces)

---

# Gallery as an umbrella control (Users build their “asset intelligence layer”)

Your Gallery writeup is already perfect for modularization. 
To make it truly “user-built”, focus on **sources** + **type handlers** + **views**.

## Gallery module roles

### A) Asset sources (where assets come from)

* `local_folder_source`
* `project_assets_source`
* `remote_http_source`
* `huggingface_source` (for Matrix-like stuff)
* `marketplace_source`

Each source implements:

* list/query
* fetch/resolve
* caching rules

### B) Type handlers (how each asset behaves)

* `image_handler` (thumb, preview, metadata)
* `video_handler`
* `audio_handler`
* `font_handler`
* `document_handler`
* `skin_handler` (ties directly into Skins)

### C) Views (how assets are shown)

* `grid_layout`
* `list_layout`
* `details_view`
* `compare_view`
* `quick_preview` (spacebar preview like classic file browsers)

### D) Selection & application adapters

* selection modes: single/multi
* `apply_adapters`:

  * “apply selected image to Studio element”
  * “apply selected font to Skins typography”
  * “apply selected skin to runtime”

## Gallery manifest ideas

* enabledSources: local/project/remote
* enabledTypes: image/video/audio/font/skins
* viewsEnabled: grid/list/details/preview
* cachePolicy: aggressive | balanced | minimal

## Pubspec packages that help Gallery

* `file_picker`
* `path`, `path_provider`
* `mime`
* `extended_image` (thumb caching)
* `video_player` (light preview)
* `just_audio` (audio preview)
* `isar` / `hive` (asset index + cache metadata)
* `http` (remote sources)

---

## The “unifying glue” that makes all umbrellas compose nicely

If you want users to mix-and-match Candy/Skins/Gallery/CodeEditor/Terminal/Studio in *one app* without mess, add 3 cross-cutting registries that every umbrella can contribute to:

1. **Command Registry**

* shared command IDs (`studio.export`, `terminal.runPreset`, `editor.format`)
* binds to shortcut service(s)

2. **Panel Registry**

* everything dockable uses the same panel spec type
* so users can dock “Gallery > Assets” next to “CodeEditor > Diagnostics”

3. **Asset Slot / Apply Registry**

* a standard way to say: “I can accept an Image here”
* Gallery can then “apply” into any tool consistently

This makes ButterflyUI feel like an “application platform”, not disconnected mega-controls.

---

## ButterflyUI Control Catalog (detailed):

These controls are not simple layout primitives.
They are higher-level visual and stylistic systems that give ButterflyUI its distinct character.

They are designed to:
- Be token-aware (integrate with Skins)
- Remain composable with Candy primitives
- Support high-performance rendering
- Provide modern, expressive UI capabilities

### Visual Dynamics & Advanced Gradients

- `animated_gradient` ✅
  A dynamic gradient system that supports time-based animation.
  Features may include:
  - color interpolation over time
  - animated angle rotation
  - shifting stop positions
  - looping and ping-pong modes
  - performance throttling
  Designed for backgrounds, hero sections, and dynamic surfaces.
  Should support GPU acceleration where possible.

- `gradient` ✅
  Structured gradient definition layer.
  Supports:
  - linear gradients
  - radial gradients
  - conic/sweep gradients
  - multiple color stops
  - opacity layering
  Should integrate with token colors and responsive overrides.

- `gradient_editor` ✅
  Visual editor for constructing gradients.
  Must support:
  - interactive stop manipulation
  - color picking per stop
  - angle controls
  - live preview
  - export to token format

- `gradient_sweep` ✅
  Specialized conic/sweep gradient control.
  Useful for:
  - progress indicators
  - circular highlights
  - radial UI accents
  Should allow animated sweep transitions.

### Avatar & Identity Controls

- `avatar_stack` ✅
  Compositional layout for multiple avatar elements.
  Designed for:
  - overlapping user indicators
  - team previews
  - stacked profile representations
  Must support:
  - overlap offset control
  - stacking order logic
  - max-visible logic with "+X" overflow badge
  - interactive hover expansion

- `badge` ✅
  Lightweight status indicator system.
  Supports:
  - numeric counts
  - dot indicators
  - severity levels (success/warn/error)
  - animated pulse mode
  Should integrate with elevation and motion tokens.

### Color & Blending Systems

- `color_picker` ✅
  Advanced color selection control.
  Features:
  - RGB / HSL / HEX input
  - alpha transparency control
  - eyedropper support (if platform allows)
  - recent colors memory
  - token-aware preview
  Must emit structured color objects, not raw strings.

- `color_swatch_grid` ✅
  Structured grid of predefined color tokens.
  Used for:
  - quick selection
  - theme preview
  - curated palettes
  Supports:
  - grouping by semantic role
  - selection highlighting
  - responsive layout

- `blend_mode_picker` ✅
  UI for selecting blend modes.
  Supports:
  - multiply
  - overlay
  - screen
  - soft light
  - custom shader blends
  Must preview effect in real time.
  Designed for advanced visual composition workflows.

### Surface Styling & Effects

- `container_style` ✅
  Structured styling system for containers.
  Encapsulates:
  - padding
  - radius
  - surface elevation
  - background layering
  - border tokens
  Allows reusable container style presets.

- `button_style` ✅
  Dedicated styling configuration for buttons.
  Should define:
  - base state
  - hover state
  - pressed state
  - disabled state
  - focus ring
  - motion behavior
  Encourages consistent interaction language across the system.

- `border` ✅
  Full border system.
  Supports:
  - per-side control
  - responsive thickness
  - dynamic color linking
  - animated border transitions

- `border_side` ✅
  Fine-grained border configuration.
  Enables:
  - different colors per side
  - mixed thickness
  - asymmetric styling

- `glass_blur` ✅
  Glassmorphism effect layer.
  Combines:
  - background blur
  - transparency
  - subtle noise overlay
  - border glow
  Must remain performant and degrade gracefully.

- `glow_effect` ✅
  Outer glow system.
  Supports:
  - soft glow
  - directional glow
  - animated intensity
  - neon-style highlights

- `neon_edge` ✅
  High-intensity edge lighting effect.
  Designed for:
  - cyberpunk aesthetics
  - gaming UI
  - high contrast modes
  Can combine with glow + animated gradients.

- `grain_overlay` ✅
  Film-grain / texture overlay.
  Adds:
  - subtle visual noise
  - depth perception
  - anti-banding texture
  Should be GPU-efficient and optional.

### Motion & Celebration Effects

- `confetti_burst` ✅
  Particle-based celebratory animation.
  Supports:
  - emission burst
  - physics simulation
  - color variation
  - duration control
  Designed for:
  - success states
  - reward events
  - milestone feedback

- `chromatic_shift` ✅
  RGB channel offset distortion effect.
  Used for:
  - glitch aesthetics
  - hover distortion
  - transition effects
  Must remain subtle and performance aware.

### Noise & Organic Systems

- `noise_field` ✅
  Procedural noise generator.
  Can generate:
  - Perlin noise
  - simplex noise
  - turbulence patterns
  Used for:
  - animated backgrounds
  - blob fields
  - shader inputs

- `noise_displacement` ✅
  Distortion effect based on noise input.
  Used for:
  - liquid effects
  - glitch transitions
  - heat-wave distortions
  Must allow strength control and animation speed.

- `blob_field` ✅
  Organic shape generator.
  Produces:
  - fluid blobs
  - animated shape morphing
  - layered blob backgrounds
  Often combined with gradients and noise.
  Ideal for modern hero sections and dynamic surfaces.

### Launch & Identity

- `splash` ✅
  Entry-screen presentation control.
  Used for:
  - application startup
  - loading states
  - brand reveal
  - animated logo transitions
  Supports:
  - timed transitions
  - background effects
  - progress indicators
  - optional skip behavior
  Should integrate with animation + gradient systems.

- `emoji_icon` ✅
  Emoji-based icon renderer.
  Used when:
  - lightweight visual symbol is needed
  - expressive UX is preferred over SVG
  Must support:
  - scalable rendering
  - token-based sizing
  - fallback compatibility

- `emoji_picker` ✅
  Emoji selection  interface.
  Supports:
  - category grouping
  - search
  - recent emojis
  - skin tone variants
  Should emit structured emoji metadata.

### Forms & Input Systems

- `auto_form` ✅
  Schema-driven form generator.
  Generates forms automatically based on:
  - field definitions
  - validation rules
  - token-based styling
  Supports:
  - dynamic field visibility
  - validation states
  - submit hooks
  - layout configuration

- `combo_box` ✅
  Hybrid input + dropdown selector.
  Supports:
  - free text input
  - suggestion list
  - keyboard navigation
  - async options loading

- `dropdown` ✅
  Structured dropdown selector.
  Must support:
  - single-select
  - grouped items
  - disabled options
  - animated open/close

- `multi_pick` ✅
  Multi-selection input control.
  Used for:
  - tag selection
  - category filters
  - multi-assign interfaces
  Should integrate with chip system.

- `filepicker` ✅
  File selection control.
  Supports:
  - local file browsing
  - drag-and-drop
  - file type filtering
  - multi-file mode
  Should return structured file metadata.

### Date & Time Controls

- `date_select` ✅
  Single date picker.
  Must support:
  - calendar view
  - month navigation
  - locale formatting
  - disabled date rules

- `date_range` ✅
  Dual date selector for range picking.
  Supports:
  - start/end logic
  - visual range highlighting
  - validation constraints

- `date_span` ✅
  Preset-based time span selector.
  Examples:
  - last 7 days
  - last 30 days
  - this month
  - custom
  Useful for analytics dashboards.

### Navigation & Structural UI

- `breadcrumb_bar` ✅
  Hierarchical navigation indicator.
  Displays:
  - path structure
  - clickable ancestors
  - optional dropdown on levels
  Used for:
  - file navigation
  - settings hierarchy
  - multi-level apps

- `filter_chips_bar` ✅
  Horizontal list of filter chips.
  Supports:
  - toggling
  - multi-select
  - removable chips
  - dynamic chip creation
  Often paired with Gallery or dashboards.

- `drag_region` ✅
  Region that enables window dragging (desktop apps).
  Important for:
  - custom title bars
  - frameless windows
  Must respect platform boundaries.

- `container` ✅
  Flexible structural wrapper.
  Used for:
  - grouping
  - styling
  - layout isolation
  This is a frequently reused high-level wrapper in application-level components.

### Chat & Messaging Systems

- `chat` ✅
  Full conversation container.
  Manages:
  - message list
  - input field
  - scroll behavior
  - message grouping
  - timestamps
  Designed for AI, support, or social interfaces.

- `chat_bubble` ✅
  Individual styled message container.
  Supports:
  - sender alignment
  - message grouping
  - avatar integration
  - status indicators

- `message_bubble` ✅
  More generic message container.
  Used outside chat contexts (notifications, system messages).
  Can support:
  - severity styling
  - icon embedding
  - inline actions

### Content Rendering

- `markdown` ✅
  Markdown rendering component.
  Must support:
  - headings
  - code blocks
  - lists
  - links
  - tables
  - inline styling
  Should sanitize input safely.

- `code_block` ✅
  Styled code display.
  Supports:
  - syntax highlighting
  - copy button
  - line numbers
  - optional diff highlight

- `html` ✅
  Safe HTML rendering component.
  Must:
  - sanitize content
  - prevent script execution
  - allow safe inline styling
  Used for trusted dynamic content.

### Data Visualization

- `bar_chart` ✅
  Structured bar visualization component.
  Supports:
  - categorical datasets
  - stacked bars
  - grouped bars
  - animated transitions
  - tooltips

- `line_chart` ✅
  Time-series or continuous data visualization.
  Supports:
  - multiple data lines
  - smooth curves
  - zoom/pan (optional)
  - interactive tooltips
  - animation on data update
  Designed for dashboards and analytics.

### Gallery Integration

- `item_tile` ✅
  Reusable tile component for content display.
  Can represent:
  - assets
  - products
  - cards
  - preview items
  Should support:
  - hover states
  - selectable mode
  - action overlays

### Overlays & System UI

- `notification_host` ✅
  The central overlay manager for notifications and transient UI messages.
  Responsibilities:
  - owns the overlay layer where toasts/snackbars/banners are rendered
  - manages stacking order, placement, and safe-area offsets
  - handles timing (auto-dismiss), persistence, and queueing
  - resolves collisions (multiple notifications at once)
  - optionally supports interactive notifications (actions, undo, open)
  Think of it as the “OS notification center” for ButterflyUI apps.

- `bottom_sheet`
  A modal sheet that slides in from the bottom (mobile-first pattern, still great on desktop).
  Designed for:
  - quick actions
  - contextual menus
  - compact forms
  - pickers and filters
  Should support:
  - snap points (collapsed/half/full)
  - drag-to-dismiss
  - background scrim and focus trapping
  - keyboard-safe layout on mobile

- `modal` ✅
  Focused blocking dialog surface for confirmation and structured workflows.
  Used for:
  - destructive confirmations
  - short forms/wizards
  - settings or detail popups
  Should support:
  - focus trapping and keyboard navigation
  - backdrop dismiss rules
  - primary/secondary actions
  - safe serialization of open state and payload

- `toast` ✅
  Lightweight transient status message for non-blocking feedback.
  Useful for:
  - save success/error feedback
  - clipboard and quick-action confirmations
  - short-lived background task updates
  Should support:
  - auto-dismiss timing and queueing
  - optional action button (undo/retry)
  - placement and stacking coordination
  - severity styling (info/success/warn/error)

### Navigation & Routing

- `route` ✅
  Declarative routing node that represents a navigation destination/state.
  Responsibilities:
  - defines route identity (path/name/params)
  - carries page configuration (title, transitions, guards)
  - binds to navigation system (push/pop/replace)
  Should be serializable so navigation can be restored.

- `page_nav` ✅
  Page navigation control (the “navigator UI”).
  Handles:
  - switching between pages/routes
  - back/forward behavior (if supported)
  - page transition coordination
  Commonly paired with sidebars, tab bars, or breadcrumb systems.

- `page_stepper` ✅
  Multi-step navigation component for guided flows.
  Great for:
  - onboarding
  - setup wizards
  - checkout-style sequences
  Should support:
  - step validation/locking
  - next/previous controls
  - step indicators and completion states
  - optional branching logic for advanced flows

### Progress & Lightweight Insight

- `progress` ✅
  A reusable progress presentation control.
  Supports:
  - determinate progress (0–100%)
  - indeterminate spinner/loop
  - labeled progress states (“Downloading…”, “Indexing…”, etc.)
  Should integrate with:
  - async actions
  - Terminal execution states
  - loading skeleton patterns

- `spark_plot` ✅
  Compact micro-visualization for quick trends.
  Used for:
  - dashboard cards
  - “last 7 days” trend previews
  - inline analytics
  Must be lightweight, fast to render, and readable at small sizes.

- `bar_plot` ✅
  Bar-style plotting control (often simpler and more compact than a full chart).
  Useful for:
  - tiny distribution previews
  - mini histograms
  - compact comparisons
  Should support:
  - tooltips
  - simple labels
  - optional normalization

### Layout & Composition

- `split_pane` ✅
  Resizable split layout system.
  Essential for desktop-style apps (editors, IDEs, Studio-like tools).
  Responsibilities:
  - horizontal or vertical split
  - draggable divider with constraints (min/max sizes)
  - persistence (remember split ratio)
  - optional multi-split (nestable panes)
  This is the backbone of “professional tool” layouts.

- `align` ✅
  Alignment control for positioning a child inside available space.
  Used heavily as glue:
  - aligning overlays
  - anchoring tooltips
  - placing badges/icons in corners
  Should cooperate with responsive rules and safe areas.

### Data Display & Structured Content

- `table_view` ✅
  Structured table renderer for datasets.
  Supports:
  - columns/rows with typed cells
  - sorting and basic filtering (optional)
  - row selection (single/multi)
  - virtualization for large tables
  - sticky headers (optional)
  Used for “real software” screens: logs, downloads, settings lists, analytics.

- `accordion` ✅
  Expand/collapse container for grouped content.
  Designed for:
  - settings sections
  - FAQs
  - inspector groups
  Should support:
  - single-open or multi-open behavior
  - smooth expand animations
  - header actions (icons, toggles)

### Action Surfaces & Async UX

- `action_bar` ✅
  A horizontal command strip for high-priority actions.
  Common in:
  - editor toolbars
  - selection contexts (“3 items selected”)
  - bottom action areas in mobile layouts
  Should support:
  - primary/secondary grouping
  - overflow handling (“…” menu)
  - disabled state logic tied to selection/validation

- `async_action_button` ✅
  A button specialized for async tasks.
  Must handle the full lifecycle:
  - idle → loading → success/failure
  - disables double-click execution
  - optional inline progress indicator
  - optional “retry” affordance on failure
  A small control that dramatically improves UX consistency.

### Tooling Panels (Editor-Grade UI)

- `adjustment_panel` ✅
  A panel for controlling continuous adjustments (sliders/knobs/toggles).
  Used for:
  - image/video/audio adjustments
  - theme tweaking (hue, blur, intensity)
  - tool settings (brush size, smoothing)
  Should support:
  - grouped controls
  - reset-to-default per group
  - fine-grained numeric input

- `brush_panel` ✅
  Specialized panel for brush-based tools.
  Designed for:
  - drawing/painting
  - masking
  - sculpt/erase workflows
  Typical controls:
  - size
  - hardness/softness
  - opacity/flow
  - blend mode / brush type
  Often paired with `canvas` and effects.

- `bounds_probe` ✅
  Debug/inspection utility that measures layout bounds.
  Useful for:
  - visual debugging (hitboxes, padding, alignment)
  - editor tooling (“why is this clipping?”)
  - responsive diagnostics
  Should be optional and low-overhead when disabled.

### Attachments & Media Tiles

- `attachment_tile` ✅
  A tile representation for attachments (files/media).
  Used in:
  - chat attachments
  - upload queues
  - document lists
  Should support:
  - preview icon/thumbnail
  - filename + metadata (size/type)
  - actions (open/download/remove)
  - progress indicator when uploading/downloading

- `audio` ✅
  Audio presentation/control surface.
  Can be:
  - lightweight player (play/pause, seek)
  - waveform preview
  - metadata display (duration, codec)
  Often paired with Gallery and attachments.

### Web & Rendering Surfaces

- `webview` ✅
  Embedded web content renderer.
  Used for:
  - documentation pages
  - embedded tools (web apps inside desktop)
  - OAuth/login flows (careful)
  Should handle:
  - navigation policies (allowed domains)
  - sizing and focus
  - message bridge (optional) for JS ↔ app communication

- `canvas` ✅
  Custom drawing surface for procedural or tool-driven rendering.
  Used for:
  - editors (Studio canvas, brush tools)
  - visual effects previews
  - custom graphs/plots
  Should support:
  - high-DPI rendering
  - input events (pointer/gesture)
  - optional layers (selection overlays, guides)
  and should integrate with motion/effects when needed.

### Meta: Artifact UI Integration

- `artifact_card` ✅
  A structured card component for presenting “artifacts” (generated outputs, files, exports, results).
  Intended for:
  - showing an output preview (image/text/file)
  - metadata (name, size, created time)
  - actions (open, copy, export, pin)
  This is especially useful in AI workflows (chat results, generated assets, build outputs).

### Layout & Positioning Utilities

- `center`
  Alignment wrapper that positions its child in the exact center of available space.
  Unlike raw alignment primitives, this control is intended for:
  - empty states
  - loading screens
  - hero sections
  - modal content
  Should respect responsive rules and safe-area constraints.

- `flex_spacer`
  Flexible spacing element designed for flex-style layouts.
  Used to:
  - push elements apart in toolbars
  - distribute space dynamically
  - maintain proportional spacing
  Unlike static `spacer`, this is ratio-aware and participates in layout negotiation.

- `frame`
  Structural boundary wrapper.
  Used to:
  - visually isolate components
  - simulate device frames (previews)
  - create window-like containers
  May support:
  - resizable bounds
  - border + shadow presets
  - title/header slot

### Lists, Chips & Selection UX

- `check_list`
  Structured checklist component.
  Designed for:
  - task lists
  - configuration options
  - multi-select states
  Supports:
  - grouped sections
  - indeterminate states
  - validation hooks

- `chip`
  Compact interactive element used for:
  - tags
  - filters
  - selected values
  Should support:
  - removable mode
  - toggle mode
  - icon prefix/suffix
  - disabled and active states

- `context_action_bar`
  Context-sensitive action strip.
  Appears when:
  - items are selected
  - a special state is active
  Provides:
  - bulk actions
  - contextual tools
  - quick operations
  Should auto-hide when context disappears.

### Numeric & Data Controls

- `count_stepper`
  Increment/decrement numeric control.
  Used for:
  - quantity input
  - pagination size
  - numeric adjustments
  Should support:
  - min/max constraints
  - press-and-hold acceleration
  - manual text override

- `data_source_view`
  Structured display of connected data source.
  Used for:
  - showing API endpoints
  - database connections
  - file sources
  Can display:
  - status (connected/disconnected)
  - metadata
  - refresh/reconnect actions

- `details_pane`
  Side panel for displaying contextual details.
  Often paired with:
  - table_view
  - gallery
  - explorer
  Should support:
  - collapsible sections
  - editable fields
  - action footer

### Drag & Drop System

- `drag_handle`
  Visual affordance for draggable items.
  Usually:
  - small icon/grip
  - visible on hover
  - indicates reorder capability

- `drag_payload`
  Structured object describing what is being dragged.
  Contains:
  - type identifier
  - metadata
  - source reference
  Enables safe drop validation.

- `drop_zone`
  Target area for drop operations.
  Should support:
  - hover highlight
  - validation feedback (allowed/denied)
  - insertion indicators (before/after/inside)

This trio (`drag_handle`, `drag_payload`, `drop_zone`) forms a clean drag architecture.

### Cropping, Curves & Editing Tools

- `crop_box`
  Interactive cropping overlay.
  Used for:
  - image editing
  - video trimming
  - preview selection
  Supports:
  - resizable bounds
  - aspect ratio lock
  - snap-to-grid
  - live dimension display

- `curve_editor`
  Interactive curve manipulation control.
  Used for:
  - animation easing curves
  - color correction curves
  - volume automation
  Supports:
  - draggable control points
  - bezier handles
  - grid snapping
  - preset curve selection

- `flow_field`
  Procedural motion visualization.
  Represents:
  - directional vector fields
  - motion simulations
  - animated background movement
  Can be used for:
  - advanced UI effects
  - tool previews
  - experimental visuals

### Navigation & Breadcrumb Systems

- `crumb_trail`
  Lightweight breadcrumb-style navigation.
  Designed for:
  - file paths
  - nested settings
  - hierarchical explorers
  Should support:
  - clickable segments
  - overflow handling
  - truncation for deep paths

### Buttons & Interaction Variants

- `elevated_button`
  A button variant with elevation and depth.
  Designed for:
  - primary calls-to-action
  - emphasis areas
  Supports:
  - elevation animation on hover
  - shadow token integration
  - disabled/pressed states

- `focus_anchor`
  Invisible or subtle anchor point used to manage focus.
  Used for:
  - keyboard navigation
  - accessibility flows
  - scroll-to-focus patterns
  Important for building accessible, keyboard-first apps.

### Filters & Drawers

- `filter_drawer`
  Slide-out panel dedicated to filtering options.
  Often paired with:
  - Gallery
  - table_view
  - dashboards
  Supports:
  - grouped filters
  - reset/apply controls
  - persistent open/close state

### Cursor & Interaction Feedback

- `cursor`
  Custom cursor control.
  Enables:
  - pointer style overrides
  - custom hover cursors
  - tool-specific cursors (brush, crosshair)
  May support:
  - animated cursor visuals
  - context-aware switching

### Download & Transfer

- `download_item`
  UI representation of a downloadable resource.
  Displays:
  - progress
  - speed
  - file size
  - status (queued/downloading/complete/failed)
  Integrates with progress and async systems.

### Folding & Layering

- `fold_layer`
  Layer that visually “folds” or collapses content.
  Used for:
  - advanced reveal animations
  - layered UI transitions
  - creative folding interactions
  Must integrate with animation + transition tokens.

### Field Grouping

- `field_group`
  Logical grouping container for related form fields.
  Supports:
  - label/header
  - validation summary
  - collapsible sections
  - layout alignment
  Used heavily in forms and adjustment panels.

### Gesture & Interaction Regions

- `gesture_area`
  High-level interaction capture zone.
  Designed for:
  - drag gestures
  - pinch/zoom
  - swipe detection
  - long press
  - multi-pointer interaction
  Responsibilities:
  - normalize pointer/touch/mouse events
  - prevent gesture conflicts
  - emit structured gesture events
  Often paired with canvas, editors, and complex layouts.

- `hover_region`
  Dedicated hover-detection wrapper.
  Used for:
  - tooltips
  - contextual buttons
  - hover highlights
  Should:
  - debounce rapid enter/exit
  - expose hover state for animation
  - integrate with cursor control

- `cursor`
  (Previously defined) but often integrated here —
  used to dynamically change cursor style inside gesture areas.

### Icon & Glyph Systems

- `glyph`
  Low-level symbolic rendering control.
  Represents:
  - icon glyphs
  - vector symbols
  - symbolic UI markers
  Should support:
  - font-based glyphs
  - vector paths
  - token-based sizing and color

- `glyph_button`
  Minimalist symbolic button built around glyph.
  Designed for:
  - toolbar icons
  - close buttons
  - quick actions
  Should support:
  - hover/press feedback
  - tooltip integration
  - accessibility labeling

- `icon_button`
  Higher-level button specialized for icon-only interaction.
  May include:
  - badge overlay
  - toggle state
  - focus ring

- `icon_picker`
  Selection UI for choosing icons.
  Supports:
  - searchable icon sets
  - categorized groups
  - live preview
  Should integrate with Skins icon tokens.

### Grid & Guides

- `grid`
  Structured layout grid system.
  Used for:
  - dashboards
  - responsive design layouts
  - design tooling
  Should support:
  - fixed columns
  - fluid columns
  - snapping integration
  - optional debug grid overlay

- `guides_manager`
  Visual alignment guide system.
  Used in editors (Studio-like workflows).
  Supports:
  - vertical/horizontal guides
  - snapping to guides
  - guide creation/removal
  - persistent layout memory

### Histogram & Data Visualization

- `histogram_view`
  Statistical distribution visualization.
  Used for:
  - image analysis
  - analytics dashboards
  - performance metrics
  Must support:
  - bin control
  - dynamic scaling
  - overlay lines (optional)

- `histogram_overlay`
  Overlay version of histogram.
  Used on top of:
  - images (brightness analysis)
  - charts
  - canvas
  Should remain semi-transparent and non-blocking.

- `line_plot`
  Continuous data visualization component.
  Used for:
  - analytics graphs
  - motion curves
  - real-time data feeds
  Supports:
  - smoothing
  - zoom
  - multiple lines
  - interactive inspection

### History & State Systems

- `history_stack`
  Visual representation of historical states.
  Used for:
  - undo/redo stacks
  - action logs
  - timeline previews
  Should:
  - show snapshot previews (optional)
  - indicate active state
  - integrate with editor workflows

### Layering Architecture

- `layer`
  Fundamental compositing unit.
  Used to:
  - isolate rendering
  - apply effects to subtrees
  - manage z-ordering
  Should support:
  - visibility toggling
  - blending modes
  - independent transforms

- `layer_list`
  UI representation of stacked layers.
  Designed for:
  - image editors
  - design tools
  - scene builders
  Supports:
  - reorder via drag
  - visibility toggle
  - lock state
  - thumbnail preview

- `layer_mask_editor`
  Advanced mask editing interface.
  Used for:
  - selective visibility
  - alpha masking
  - non-destructive edits
  Should support:
  - brush-based mask painting
  - gradient masks
  - preview toggling

### Advanced Morphing & Motion

- `liquid_morph`
  Organic shape transformation control.
  Used for:
  - smooth element transitions
  - blob-like UI motion
  - playful hover animations
  Must support:
  - bezier-based morphing
  - physics-based interpolation
  - token-driven duration

- `morphing_border`
  Dynamic border shape animation.
  Used for:
  - active states
  - attention highlights
  - modern interactive aesthetics
  Should:
  - animate radius and shape
  - integrate with glow/neon effects

- `motion`
  Core motion engine interface.
  Handles:
  - spring-based movement
  - curve interpolation
  - gesture-driven transforms
  - chained animation sequences
  This is the animation backbone of ButterflyUI.

### Messaging & Social UX

- `mention_pill`
  Styled inline mention component.
  Used in:
  - chat
  - comments
  - collaborative tools
  Should:
  - highlight mentioned user
  - support click-to-profile
  - adapt to theme tokens

- `message_divider`
  Structural separator inside conversations.
  Used for:
  - date breaks
  - unread markers
  - system notices

- `message_meta`
  Metadata display for messages.
  Displays:
  - timestamp
  - status (sent/read/edited)
  - author info

### Navigation Systems

- `nav_ring`
  Circular navigation interface.
  Used for:
  - radial menus
  - quick tool access
  - gaming-style UI
  Should support:
  - segment highlighting
  - keyboard shortcuts
  - animated selection

- `navigator`
  High-level navigation manager.
  Responsible for:
  - managing route stack
  - transition animations
  - state preservation
  - nested navigation contexts
  This works closely with `route` and `page_nav`.

- `info_bar`
  Informational banner strip.
  Used for:
  - warnings
  - system messages
  - contextual hints
  Should:
  - support severity levels
  - allow dismiss action
  - integrate with notification_host

### Keybinding & Input Tools

- `keybind_recorder`
  Interactive keybinding capture tool.
  Used for:
  - customizing shortcuts
  - editor configuration
  Should:
  - detect modifier combinations
  - prevent conflicts
  - display human-readable key name.

### Bars, Notices & Lightweight Messaging

- `notice_bar`
  Persistent informational bar.
  Used for:
  - system notices
  - update alerts
  - environment warnings
  Unlike `snackbar`, this is typically static until dismissed.
  Should support:
  - severity levels
  - inline actions
  - dismiss controls

- `snackbar` ✅
  Temporary transient notification.
  Used for:
  - quick feedback (“Saved”, “Copied”)
  - undo affordances
  Must support:
  - auto-dismiss timing
  - stacked behavior
  - accessibility announcements

- `reaction_bar`
  Compact reaction selector.
  Used in:
  - chat systems
  - comments
  - social features
  Supports:
  - emoji reactions
  - counters
  - hover expand behavior

### Input & Selection Controls

- `numeric_field`
  Number-specific input control.
  Must support:
  - step increment
  - validation (min/max)
  - precision control
  - optional unit display

- `option`
  Selectable option unit.
  Used inside:
  - dropdowns
  - segmented switches
  - radio groups
  Should support:
  - disabled state
  - metadata display
  - selection highlighting

- `select_option`
  Higher-level option selection control.
  Supports:
  - single or multi-select
  - search integration
  - async loading

- `path_field`
  File system path input.
  Designed for:
  - project directory selection
  - export destinations
  Should support:
  - path validation
  - browse button integration
  - auto-complete (optional)

- `pressable`
  Interaction wrapper for press gestures.
  Used when:
  - custom components need press behavior
  - ripple or animated feedback is required
  Should expose:
  - pressed state
  - hover state
  - focus state

### Layout Safety & Responsive Systems

- `safe_area`
  Layout wrapper that respects device safe zones.
  Used for:
  - mobile notches
  - system UI overlays
  - desktop window chrome
  Ensures no content is clipped.

- `scrollable_column`
  Vertical scroll container.
  Supports:
  - inertia scrolling
  - optional scrollbars
  - scroll position restoration

- `scrollable_row`
  Horizontal scroll container.
  Used for:
  - carousels
  - horizontal lists
  - tag strips

- `snap_grid`
  Alignment grid for snapping layout elements.
  Used in:
  - design tools
  - editors
  - layout builders
  Should support:
  - adjustable spacing
  - visual overlay toggle
  - snap tolerance control

- `shadow_stack`
  Layered shadow composition system.
  Allows:
  - multiple shadow layers
  - elevation blending
  - dynamic depth styling

### Navigation Systems

- `rail_nav`
  Vertical navigation rail.
  Common in:
  - desktop apps
  - dashboards
  Supports:
  - icon + label modes
  - collapsible behavior
  - active state indicator

- `segment_bar`
  Horizontal segmented navigation.
  Used for:
  - view switching
  - tab-like interaction
  Should support:
  - animated indicator
  - token-driven active styling

- `segmented_switch`
  Toggle-style segmented control.
  Designed for:
  - switching modes
  - binary/multi-state selection
  Should provide:
  - smooth animated selection transition

- `side_drawer`
  Slide-in navigation drawer.
  Used for:
  - main menu
  - contextual navigation
  Supports:
  - swipe-to-open
  - overlay scrim
  - persistent or temporary modes

- `side_panel`
  Persistent side content area.
  Often used for:
  - inspectors
  - filters
  - details panes

- `slide_panel`
  Animated sliding panel.
  Designed for:
  - temporary tool panels
  - overlays
  - progressive disclosure

### Overlays & Visual Layers

- `overlay`
  Generic overlay container.
  Used for:
  - tooltips
  - popovers
  - modal layers
  Must handle:
  - positioning
  - stacking order
  - click-outside behavior

- `progress_overlay`
  Full-screen or container-level loading overlay.
  Used during:
  - blocking operations
  - background processing
  Should:
  - prevent interaction beneath
  - show progress indicator
  - fade in/out smoothly

- `rulers_overlay`
  Overlay for measurement rulers.
  Used in:
  - design tools
  - editors
  Displays:
  - horizontal and vertical rulers
  - unit markers

- `ruler_guides`
  Interactive ruler guides.
  Supports:
  - draggable guides
  - snapping integration
  - persistent guide storage

### Data & Visualization

- `pie_plot`
  Circular data distribution chart.
  Supports:
  - labeled slices
  - hover tooltips
  - animated transitions
  - donut mode

- `rating_display`
  Visual rating component.
  Used for:
  - star ratings
  - score display
  - feedback systems
  Should support:
  - fractional values
  - hover preview

### Media & Visual Effects

- `pixelate`
  Pixelation effect layer.
  Used for:
  - blur alternative
  - censorship
  - stylized UI
  Should allow:
  - adjustable pixel size
  - animation support

- `parallax`
  Multi-layer depth illusion effect.
  Used for:
  - immersive hero sections
  - scene-based UIs
  Supports:
  - scroll-driven movement
  - pointer-based depth shift

- `ripple_burst`
  Expanding ripple animation.
  Used for:
  - press feedback
  - highlight events
  Should be performance-friendly and token-aware.

- `shimmer`
  Loading shimmer placeholder.
  Used for:
  - skeleton loading states
  - perceived performance improvement

### Reordering & Queues

- `queue_list`
  Ordered task queue visualization.
  Used for:
  - downloads
  - render queues
  - job pipelines
  Should support:
  - reordering
  - status display
  - progress integration

- `reorderable_list`
  Drag-reorderable list control.
  Supports:
  - visual insertion indicator
  - animated reflow
  - keyboard accessibility

- `reorderable_tree`
  Hierarchical drag-reorder tree.
  Used for:
  - layer systems
  - file explorers
  - nested categories
  Must support:
  - nested drop targets
  - expand/collapse
  - validation rules

### Panels & Resizing

- `resizable_panel`
  Panel with adjustable size.
  Supports:
  - drag-to-resize
  - min/max constraints
  - persisted size state
  Common in:
  - editors
  - split layouts

### Ownership & Persona

- `ownership_marker`
  Visual indicator of ownership.
  Used in:
  - collaborative environments
  - multi-user editing
  Displays:
  - user color
  - avatar badge
  - lock indicators

- `persona`
  Structured user identity component.
  Displays:
  - avatar
  - name
  - status
  Often used in chat and collaborative tools.

### Scene & Preview Systems

- `scene_view`
  High-level rendering surface for scene-based UI.
  Used for:
  - 2D/3D scene composition
  - design previews
  - animation staging
  Should support:
  - layered rendering
  - camera control (optional)
  - interactive selection

- `preview_surface`
  Lightweight rendering container for previewing:
  - components
  - assets
  - skins
  Should isolate:
  - style context
  - scaling rules
  - background

### Messaging Enhancements

- `quoted_message`
  Nested message reference block.
  Used in chat systems for:
  - reply context
  - threaded conversation
  Should visually distinguish:
  - original sender
  - excerpt text

### Structural Definitions

- `pane_spec`
  Configuration descriptor for panel layout.
  Defines:
  - initial size
  - docking rules
  - resizability
  - allowed positions

- `outline`
  Stroke styling modifier.
  Often used for:
  - focus indication
  - high contrast modes
  - selection highlighting

### Table & List Enhancements

- `sortable_header`
  Interactive table header for sortable columns.
  Designed for:
  - ascending/descending toggling
  - multi-column sort (optional)
  - visual sort indicators
  Should integrate with `table_view` and data models without mutating source data directly.

- `sticky_list`
  Scrollable list with sticky headers.
  Used for:
  - grouped datasets
  - categorized content
  - alphabetical lists
  Supports:
  - pinned group headers
  - smooth transition between groups
  - virtualization for performance

### Layout & Structural Utilities

- `spacer`
  Flexible or fixed spacing element.
  Used to:
  - maintain layout rhythm
  - enforce consistent gaps
  - participate in flex-based distribution

- `view_stack`
  Layered view container for switching between views.
  Used for:
  - tab content
  - state transitions
  - route transitions
  Should support:
  - animated crossfades
  - slide transitions
  - state preservation

- `visibility`
  Conditional rendering wrapper.
  Controls:
  - show/hide behavior
  - optional maintain-state mode
  - animated appearance/disappearance

### Input & Form Refinement

- `text_area`
  Multi-line text input control.
  Supports:
  - auto-resize
  - character limits
  - validation states
  - optional markdown support

- `text_field_style`
  Styling configuration for text inputs.
  Defines:
  - border modes
  - focus states
  - error visuals
  - label behavior
  Encourages consistent form aesthetics.

- `span_slider`
  Range-based slider with dual handles.
  Used for:
  - min/max filtering
  - timeline trimming
  - numeric ranges
  Should support:
  - tooltips
  - snapping
  - keyboard accessibility

- `time_select`
  Time-specific selection control.
  Supports:
  - hour/minute selection
  - 12h/24h formats
  - locale formatting

- `submit_scope`
  Logical wrapper that groups form submission.
  Ensures:
  - validation occurs within defined scope
  - nested forms don’t conflict
  - async submission states are isolated

### Motion & Animation Coordination

- `stagger`
  Sequential animation coordinator.
  Used for:
  - staggered list reveals
  - cascading transitions
  - delayed child animations
  Should allow:
  - configurable delay intervals
  - direction control
  - easing integration

- `tilt_hover`
  Subtle 3D tilt effect on hover.
  Used for:
  - cards
  - preview surfaces
  - interactive elements
  Should:
  - respond to pointer position
  - remain performance-aware
  - gracefully degrade on touch devices

- `time_travel`
  State navigation control.
  Designed for:
  - undo/redo navigation
  - state inspection
  - development debugging
  Should integrate with:
  - history_stack
  - timeline

### Timeline & History Systems

- `timeline`
  Chronological event visualization component.
  Used for:
  - history tracking
  - activity logs
  - editing sessions
  Should support:
  - grouped events
  - expandable entries
  - time markers
  - scrollable navigation

- `typing_indicator`
  Real-time typing feedback indicator.
  Used in:
  - chat systems
  - collaborative tools
  Should:
  - animate subtle dot or wave pattern
  - auto-hide when inactive

### Media & Rendering

- `video`
  Video rendering component.
  Supports:
  - playback controls
  - preview thumbnails
  - loop/mute modes
  - overlay controls
  Should integrate with Gallery and asset systems.

- `vector_view`
  Vector rendering surface.
  Used for:
  - SVG display
  - scalable graphics
  - icon systems
  Should:
  - preserve crisp scaling
  - support token-based coloring
  - allow dynamic path updates

- `sprite`
  Sprite rendering control.
  Used for:
  - game-like UI
  - animated icons
  - frame-based animation
  Should support:
  - sprite sheets
  - frame control
  - animation speed configuration

### Navigation & Structural Bars

- `top_bar`
  Primary top-level navigation bar.
  Typically contains:
  - app title
  - global actions
  - profile/menu
  - breadcrumb integration
  Should support:
  - sticky behavior
  - responsive collapse

- `tag_chip`
  Stylized tag element.
  Used for:
  - categorization
  - quick filters
  - status labeling
  Supports:
  - removable mode
  - clickable mode
  - token-based coloring

- `status_mark`
  Compact state indicator.
  Used for:
  - online/offline
  - synced/unsynced
  - success/error state
  Must remain visually subtle yet clear.

### Trees & Symbol Systems

- `symbol_tree`
  Hierarchical symbol explorer.
  Used in:
  - code editors
  - design tools
  - structured content browsers
  Supports:
  - expandable nodes
  - selection highlighting
  - search integration

### Viewport & Scene Management

- `viewport`
  Scroll/zoom constrained rendering window.
  Used for:
  - canvas editing
  - scene rendering
  - design previews
  Should support:
  - pan & zoom integration
  - clipping
  - transformation tracking

- `scene_view`
  (Previously defined) pairs closely with viewport for scene-level rendering.

### File & System Views

- `file_system`
  File system browser abstraction.
  Used for:
  - local file navigation
  - project browsing
  - save/load dialogs
  Should support:
  - tree + list modes
  - file metadata display
  - permission/state indicators


---

### Final Architectural Note

With this final batch, ButterflyUI now includes:

- Primitive layout and styling (Candy)
- Token-driven identity (Skins)
- Asset intelligence (Gallery)
- IDE-grade editing (CodeEditor)
- Execution tooling (Terminal)
- Visual editor environment (Studio)
- And a deep catalog of professional core controls

This is no longer a UI toolkit.

It is a layered application platform.
